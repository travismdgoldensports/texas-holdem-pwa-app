<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Texas Hold'em</title>

<!-- iOS PWA support -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="icons/apple-touch-icon-180.png">

  <!-- Manifest -->
  <link rel="manifest" href="manifest.webmanifest">
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="icons/favicon.svg?v=1">
  <!-- Optional PNG fallbacks if you add them later
  <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32.png?v=1">
  <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16.png?v=1"> -->
  
<style>
:root {
  --bg:#061020;
  --felt:#0c5535;
  --felt2:#0a3d29;
  --felt-edge:#04311f;
  --panel:rgba(12,24,42,0.9);
  --panel-border:#244058;
  --accent:#ffd166;
  --accent-strong:#f7b733;
  --text:#f5f7ff;
  --muted:#9bb1d1;
  --danger:#ff6b6b;
  --chip-green:#38d996;
  --chip-red:#ef476f;
  --chip-blue:#4ea1ff;
  --chip-gold:#f7b733;
  --card-bg:#fff;
  --card-red:#e63946;
  --card-black:#212529;
  --glow:0 0 20px rgba(72,214,144,0.35);
  --radius:14px;
  --chip-scale:1;
  --card-scale-player:1;
  --card-scale-opponent:1;
  font-family:"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
}

@media (max-width: 1366px){
  :root{
    --chip-scale:0.7;
    --card-scale-player:0.96;
    --card-scale-opponent:0.7;
  }
}

@media (max-width: 700px){
  :root{
    --chip-scale:0.5;
    --card-scale-player:0.92;
    --card-scale-opponent:0.6;
  }
}

*{box-sizing:border-box}

body{
  margin:0;
  background:radial-gradient(circle at top,#0d1b3a,#060b16 70%);
  color:var(--text);
  min-height:100vh;
}

.app{
  max-width:1400px;
  margin:0 auto;
  padding:4px;
  display:flex;
  flex-direction:column;
  gap:4px;
}

header.top-bar{
  display:flex;
  justify-content:space-between;
  align-items:center;
  background:rgba(9,18,33,0.9);
  border:1px solid rgba(90,134,178,0.22);
  border-radius:var(--radius);
  padding:4px;
  box-shadow:0 12px 24px rgba(0,0,0,0.35);
}

header .title{
  font-size:20px;
  font-weight:700;
  letter-spacing:0.4px;
}

header .subtitle{
  font-size:12px;
  color:var(--muted);
}

header .meta{
  display:flex;
  flex-direction:column;
  align-items:flex-end;
  gap:6px;
}

header .meta .table-meta{
  font-size:12px;
  color:var(--muted);
  text-align:right;
}

header .top-left{
  display:flex;
  align-items:center;
  gap:12px;
}

header .title-group{
  display:flex;
  flex-direction:column;
  gap:2px;
}

.menu-button{
  display:none;
  align-items:center;
  gap:6px;
  padding:6px 12px;
  border-radius:999px;
  border:1px solid rgba(120,170,230,0.35);
  background:rgba(8,16,28,0.6);
  color:var(--text);
  font-size:13px;
  font-weight:600;
  letter-spacing:0.4px;
  cursor:pointer;
  transition:background 0.2s ease, transform 0.2s ease;
}

.menu-button:hover{
  transform:translateY(-1px);
}

.menu-button.active{
  background:rgba(68,120,200,0.35);
}

main.layout{
  display:grid;
  grid-template-columns:minmax(280px,330px) 1fr;
  grid-template-areas:'sidebar table';
  gap:18px;
  align-items:start;
}

.table-area{
  grid-area:table;
  display:flex;
  flex-direction:column;
  align-items: center;
  justify-content: center;
  gap:14px;
}

.sidebar{
  grid-area:sidebar;
  display:flex;
  flex-direction:column;
  gap:18px;
}

.sidebar-backdrop{display:none;}

@media (max-width:1080px){
  main.layout{
    grid-template-columns:1fr;
    grid-template-rows:auto auto;
    grid-template-areas:
      'table'
      'sidebar';
  }
  .app.sidebar-collapsed main.layout{
    grid-template-areas:'table';
  }

  header .meta{align-items:flex-end;}
  header .meta .table-meta{text-align:right;}
  .menu-button{display:inline-flex;}
  .sidebar{
    position:static;
  }
  .app.sidebar-collapsed .sidebar,
  .app.sidebar-open .sidebar{
    position:fixed;
    top:0;
    left:0;
    bottom:0;
    width:min(320px,80vw);
    max-width:360px;
    padding:24px 20px 32px;
    background:var(--panel);
    border-right:1px solid var(--panel-border);
    box-shadow:16px 0 32px rgba(0,0,0,0.45);
    overflow-y:auto;
    transition:transform 0.3s ease;
    z-index:220;
  }

  .app.sidebar-collapsed .sidebar{
    transform:translateX(-105%);
    pointer-events:none;
  }

  .app.sidebar-open .sidebar{
    transform:translateX(0);
    pointer-events:auto;
  }

  .app.sidebar-open{overflow:hidden;}
  .sidebar-backdrop{
    display:block;
    position:fixed;
    inset:0;
    background:rgba(5,12,24,0.65);
    opacity:0;
    pointer-events:none;
    transition:opacity 0.3s ease;
    z-index:200;
    -webkit-backdrop-filter:blur(2px);
    backdrop-filter:blur(2px);

  }

  .app.sidebar-open .sidebar-backdrop{
    opacity:1;
    pointer-events:auto;
  }

}

.table{
  position:relative;
  border-radius:50px;
  border:2px solid rgba(255,255,255,0.12);
  background:
    radial-gradient(80% 70% at 50% 50%, rgba(72,214,144,0.16), transparent 65%),
    radial-gradient(110% 100% at 50% 20%, rgba(255,255,255,0.12), transparent 70%),
    radial-gradient(120% 110% at 50% 50%, var(--felt), var(--felt2));
  min-height:480px;
  max-width: 684px;
  width: 100%;
  box-shadow:inset 0 0 65px rgba(0,0,0,0.45),0 28px 50px rgba(0,0,0,0.35);
  padding:26px;
}

.table::after{
  content:"";
  position:absolute;
  inset:14px;
  border:2px solid rgba(255,255,255,0.08);
  border-radius:44px;
  pointer-events:none;
}

.felt-label{
  text-align:center; 
  position:absolute;
  top:24px;
  left:50%;
  transform:translateX(-50%);
  text-transform:uppercase;
  font-size:12px;
  letter-spacing:4px;
  color:rgba(240,250,255,0.28);
  font-weight:600;
  pointer-events:none;
}

.pot-display{
  font-size:inherit;
  font-weight:inherit;
  color:inherit;
}

.community-cards{

  position:absolute;

  top:140px;

  left:50%;

  transform:translateX(-50%);

  --card-scale:var(--card-scale-player);

  display:flex;

  gap:calc(6px * var(--card-scale-player));

  min-height:calc(80px * var(--card-scale-player));

}

.player-ring{

  position:absolute;

  inset:0;


  z-index:3;


}

.seat{

  position:absolute;

  width:clamp(150px, calc(200px * var(--card-scale, 1)), 240px);

  display:flex;

  flex-direction:column;

  align-items:center;

  gap:1px;

  transition:transform 0.25s ease,color 0.25s ease,opacity 0.25s ease;

  pointer-events:none;

  --seat-translate-x:-50%;

  --seat-translate-y:0px;

  --card-scale:var(--card-scale-opponent);

  --card-tilt:12deg;

  --card-shift-base:28px;

  --card-shift:calc(var(--card-shift-base) * var(--card-scale, 1));

  transform:translate(var(--seat-translate-x), var(--seat-translate-y));

}

.seat.human{
  --card-scale:var(--card-scale-player);
  --card-tilt:10deg;
  --card-shift-base:26px;
}

.seat.ai{
  --card-tilt:10deg;
  --card-shift-base:26px;
}

.seat .card-row{
  display:flex;
  justify-content:center;
  align-items:flex-end;
  gap:0;
  position:relative;
  overflow:visible;
}

.seat .card-row .card{
  transform-origin:50% 85%;
  transition:transform 0.25s ease;
}

.seat .card-row .card:nth-child(1):not(:only-child){
  transform:translateX(var(--card-shift)) rotate(calc(-1 * var(--card-tilt)));
  z-index:1;
}

.seat .card-row .card:nth-child(2){
  transform:translateX(calc(var(--card-shift) * -1)) rotate(var(--card-tilt));
  z-index:2;
}

.seat .name{
  font-weight:600;
  text-align:center;
  font-size:calc(16px * var(--card-scale, 1));
  text-shadow:0 0 6px rgba(0,0,0,0.45);
  padding:2px 4px;
  border-radius:14px;
  background:rgba(4,10,20,0.72);
  -webkit-backdrop-filter:blur(4px);
  backdrop-filter:blur(4px);
  box-shadow:0 6px 16px rgba(0,0,0,0.45);
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  white-space:nowrap;
}

.seat .chip-count{
  font-size:calc(14px * var(--card-scale, 1));
  color:var(--muted);
  text-shadow:0 0 6px rgba(0,0,0,0.45);
  padding:2px 4px;
  border-radius:14px;
  background:rgba(4,10,20,0.68);
  -webkit-backdrop-filter:blur(4px);
  backdrop-filter:blur(4px);
  box-shadow:0 6px 16px rgba(0,0,0,0.38);
}

.seat .status{
  font-size:calc(13px * var(--card-scale, 1));
  min-height:calc(16px * var(--card-scale, 1));
  color:rgba(240,250,255,0.9);
  text-shadow:0 0 6px rgba(0,0,0,0.4);
  padding:2px 4px;
  border-radius:14px;
  background:rgba(4,10,20,0.64);
  -webkit-backdrop-filter:blur(4px);
  backdrop-filter:blur(4px);
  box-shadow:0 6px 16px rgba(0,0,0,0.32);
  display:flex;
  align-items:center;
  justify-content:center;
}

.seat .status:empty{
  padding:0;
  background:none;
  -webkit-backdrop-filter:none;
  box-shadow:none;
  backdrop-filter:none;
  min-height:0;
}

.seat.folded .card-row{display: none;}

.seat.out{opacity:0.3;}

.seat.active{

  transform:translate(calc(var(--seat-translate-x)), calc(var(--seat-translate-y) - 8px));

  filter:drop-shadow(0 0 12px rgba(255,255,255,0.22));

}

.seat.all-in .status{

  color:var(--chip-gold);

  font-weight:600;

}

.dealer-badge{

  position:static;

  width:22px;

  height:22px;

  border-radius:50%;

  background:rgba(255,255,255,0.92);

  color:#0b1730;

  font-weight:700;

  font-size:11px;

  display:flex;

  align-items:center;

  justify-content:center;

  box-shadow:0 4px 10px rgba(0,0,0,0.3);

  flex-shrink:0;

  line-height:1;

}


.chip-layer{

  position:absolute;

  inset:0;

  overflow:hidden;

  border-radius:inherit;

  pointer-events:none;

  z-index:2;

}

.chip-anchor{

  position:absolute;

  width:calc(40px * var(--chip-scale, 1));

  height:calc(40px * var(--chip-scale, 1));

  transform:translate(-50%, -50%);

}

.stack-anchor.stack-0{left:50%;top:95%;}

.stack-anchor.stack-1{left:15%;top:90%;}

.stack-anchor.stack-2{left:6%;top:58%;}

.stack-anchor.stack-3{left:24%;top:18%;}

.stack-anchor.stack-4{left:50%;top:8%;}

.stack-anchor.stack-5{left:76%;top:18%;}

.stack-anchor.stack-6{left:94%;top:58%;}

.stack-anchor.stack-7{left:85%;top:90%;}


.bet-anchor.bet-0{left:50%;top:76%;}
.bet-anchor.bet-1{left:34%;top:68%;}
.bet-anchor.bet-2{left:26%;top:52%;}
.bet-anchor.bet-3{left:35%;top:30%;}
.bet-anchor.bet-4{left:50%;top:26%;}
.bet-anchor.bet-5{left:65%;top:30%;}
.bet-anchor.bet-6{left:74%;top:52%;}
.bet-anchor.bet-7{left:66%;top:68%;}

.pot-anchor{left:50%;top:44%;}

.chip{

  position:absolute;

  --chip-scale-factor:var(--chip-scale, 1);

  width:calc(38px * var(--chip-scale-factor));

  height:calc(38px * var(--chip-scale-factor));

  border-radius:50%;

  display:flex;

  align-items:center;

  justify-content:center;

  font-size:calc(12px * var(--chip-scale-factor));

  font-weight:700;

  color:var(--chip-text,#09202b);

  letter-spacing:0.4px;

  background:radial-gradient(circle at 30% 30%, var(--chip-light,#fdfbff) 0%, var(--chip-dark,#b7bfd3) 70%, var(--chip-dark,#97a1bc) 100%);

  box-shadow:0 calc(8px * var(--chip-scale-factor)) calc(14px * var(--chip-scale-factor)) rgba(0,0,0,0.35);

  transition:left 0.45s ease, top 0.45s ease, transform 0.45s ease;

  will-change:left, top, transform;

}

.chip::before{

  content:'';

  position:absolute;

  inset:calc(4px * var(--chip-scale-factor));

  border-radius:50%;

  border:calc(2px * var(--chip-scale-factor)) solid rgba(255,255,255,0.65);

  opacity:0.85;

  pointer-events:none;

  z-index:0;

}

.chip::after{

  content:'';

  position:absolute;

  inset:calc(10px * var(--chip-scale-factor));

  border-radius:50%;

  background:radial-gradient(circle, var(--chip-core,#ffffff) 0%, rgba(0,0,0,0.18) 120%);

  pointer-events:none;

  z-index:0;

}

.chip-floating{z-index:120;}

.chip-small{font-size:calc(10px * var(--chip-scale-factor));}

.chip-label{position:relative;z-index:2;}

.chip.denom-1{--chip-light:#f4f5f9;--chip-dark:#c9cedb;--chip-core:#ffffff;--chip-text:#263146;}
.chip.denom-5{--chip-light:#ffd1d1;--chip-dark:#cc3b3b;--chip-core:#ffe6e6;--chip-text:#5c1f1f;}
.chip.denom-10{--chip-light:#ffe4b3;--chip-dark:#d9781a;--chip-core:#fff1d4;--chip-text:#5c3410;}
.chip.denom-25{--chip-light:#d4f8e8;--chip-dark:#1c9966;--chip-core:#eefef7;--chip-text:#104636;}
.chip.denom-50{--chip-light:#d0ecff;--chip-dark:#1f6bb5;--chip-core:#e9f5ff;--chip-text:#124064;}
.chip.denom-100{--chip-light:#f2f2f2;--chip-dark:#3b3d51;--chip-core:#e4e6f1;--chip-text:#1b1d2e;}
.chip.denom-500{--chip-light:#e8d7ff;--chip-dark:#6234c1;--chip-core:#f2e6ff;--chip-text:#361c6b;}
.chip.denom-1k{--chip-light:#ffeec0;--chip-dark:#c26f1f;--chip-core:#fff7d8;--chip-text:#5c3111;}
.chip.denom-5k{--chip-light:#ffd9ef;--chip-dark:#c32878;--chip-core:#ffe6f4;--chip-text:#5d1438;}

.seat-0{bottom:3%;left:50%;--seat-translate-x:-50%;--seat-translate-y:0px;}
.seat-1{top:70%;left:17%;--seat-translate-x:-50%;--seat-translate-y:-40%;}
.seat-2{top:44%;left:8%;--seat-translate-x:-50%;--seat-translate-y:-40%;}
.seat-3{top:12%;left:26%;--seat-translate-x:-50%;--seat-translate-y:-40%;}
.seat-4{top:11%;left:50%;--seat-translate-x:-50%;--seat-translate-y:-40%;}
.seat-5{top:12%;left:74%;--seat-translate-x:-50%;--seat-translate-y:-40%;}
.seat-6{top:44%;left:92%;--seat-translate-x:-50%;--seat-translate-y:-40%;}
.seat-7{top:70%;left:83%;--seat-translate-x:-50%;--seat-translate-y:-40%;}

.card{

  --card-scale-factor:var(--card-scale, 1);

  width:calc(58px * var(--card-scale-factor));

  height:calc(84px * var(--card-scale-factor));

  border-radius:calc(8px * var(--card-scale-factor));

  background:var(--card-bg);

  color:var(--card-black);

  border:calc(2px * var(--card-scale-factor)) solid rgba(0,0,0,0.08);

  box-shadow:0 calc(8px * var(--card-scale-factor)) calc(18px * var(--card-scale-factor)) rgba(0,0,0,0.35);

  position:relative;

  padding:calc(1px * var(--card-scale-factor));

  font-weight:600;

  display:flex;

  flex-direction:column;

  justify-content:space-between;

  font-size:calc(18px * var(--card-scale-factor));

}


.card .corner{

  display:flex;

  flex-direction:column;

  align-items:flex-start;

  gap:calc(2px * var(--card-scale-factor));

  line-height:1;

}

.card .corner.bottom{

  align-items:flex-start;

  transform:rotate(180deg);

}


.card.red{

  color:var(--card-red);

}

.card.back{

  background:linear-gradient(135deg,#1c2d5a,#0d162f 60%,#1a62a3);

  border:calc(2px * var(--card-scale-factor)) solid rgba(255,255,255,0.16);

  display:flex;

  align-items:center;

  justify-content:center;

  font-size:calc(18px * var(--card-scale-factor));
  font-weight: 700;

  letter-spacing:calc(2px * var(--card-scale-factor));

  color:rgba(250,252,255,0.75);

}

.panel{

  background:var(--panel);

  border-radius:var(--radius);

  border:1px solid var(--panel-border);

  box-shadow:0 14px 24px rgba(0,0,0,0.45);

  padding:16px;

  display:flex;

  flex-direction:column;

  gap:12px;

}

.panel h2{

  margin:0;

  font-size:16px;

  font-weight:600;

  letter-spacing:0.4px;

}

.setup-panel label{

  font-size:13px;

  color:var(--muted);

  margin-bottom:4px;

}

.setup-panel input[type=range]{

  width:100%;

}

.setup-panel input[type=number], .setup-panel input[type=text]{

  width:100%;

  padding:8px;

  border-radius:10px;

  border:1px solid rgba(120,150,190,0.3);

  background:rgba(4,10,20,0.75);

  color:var(--text);

}

.setup-panel .value-pill{

  display:inline-flex;

  align-items:center;

  padding:4px 10px;

  border-radius:999px;

  background:rgba(56,217,150,0.16);

  border:1px solid rgba(56,217,150,0.3);

  font-size:12px;

  color:#b8ffe1;

  margin-left:6px;

}

.welcome-setup{

  margin-top:16px;

  display:flex;

  flex-direction:column;

  gap:12px;

}

.welcome-setup .toggle-row label{

  margin-bottom:0;

}

.welcome-setup .value-note{

  margin-top:4px;

}

.menu-panel{

  gap:8px;

}

.menu-panel .menu-note{

  margin:0;

  font-size:13px;

  color:var(--muted);

}

button{

  cursor:pointer;

  border-radius:12px;

  border:1px solid transparent;

  padding:9px 14px;

  font-weight:600;

  font-size:14px;

  transition:background 0.2s ease,transform 0.2s ease,box-shadow 0.2s ease;

}

button.primary{

  background:linear-gradient(135deg,var(--accent),var(--accent-strong));

  color:#102436;

  box-shadow:0 12px 22px rgba(247,183,51,0.35);

}

button.ghost{

  background:transparent;

  border:1px solid rgba(120,150,190,0.35);

  color:var(--muted);

}

button.danger{

  background:rgba(255,107,107,0.18);

  border:1px solid rgba(255,107,107,0.35);

  color:#ffc8c8;

}

button.accent{

  background:rgba(56,217,150,0.25);

  border:1px solid rgba(56,217,150,0.45);

  color:#c1ffe8;

}

button:disabled{

  opacity:0.5;

  cursor:not-allowed;

  box-shadow:none;

  transform:none;

}

button:not(:disabled):hover{

  transform:translateY(-1px);

}

.controls{

  gap:14px;

}

.control-header{

  display:flex;

  justify-content:space-between;

  align-items:center;

  font-size:14px;

  color:var(--muted);

}

.control-buttons{

  display:flex;

  gap:8px;

  flex-wrap:wrap;

}

.slider-row{

  display:flex;

  flex-wrap:wrap;

  gap:10px;

  align-items:center;

}

.slider-row input[type=range]{

  flex:1 1 160px;

}

.raise-increment{

  white-space:nowrap;

  flex-shrink:0;

}

.slider-display{

  font-size:14px;

  color:var(--muted);

  min-width:120px;

}

.hidden{display:none !important;}

.log-panel .log{

  background:rgba(4,12,24,0.65);

  border-radius:12px;

  border:1px solid rgba(90,120,168,0.35);

  padding:12px;

  max-height:260px;

  overflow:auto;

  font-size:12px;

  line-height:1.4;

}

.log-panel .log-item{

  margin-bottom:6px;

}

.log-panel .log-item strong{

  color:#bfe7ff;

}

.log-panel .log-item.win{

  color:#7dffb1;

}

.log-panel .log-item.highlight{

  color:#ffe8af;

}

.leaderboard-panel ul{

  list-style:none;

  padding:0;

  margin:0;

  display:flex;

  flex-direction:column;

  gap:6px;

  font-size:13px;

}

.leaderboard-panel li{

  display:flex;

  justify-content:space-between;

  background:rgba(6,14,24,0.55);

  border-radius:10px;

  padding:6px 10px;

}

.last-hand{

  font-size:13px;

  color:var(--muted);

}

.last-hand strong{

  color:#fcefb4;

}

.table-overlay{

  position:absolute;

  inset:0;

  -webkit-backdrop-filter:blur(8px);
  backdrop-filter:blur(8px);

  background:rgba(6,12,18,0.72);

  display:flex;

  align-items:center;

  justify-content:center;

  z-index:5;

}

.table-overlay.hidden{display:none;}

.overlay-card{

  background:rgba(8,18,32,0.95);

  border:1px solid rgba(90,150,220,0.35);

  border-radius:20px;

  padding:26px;

  text-align:center;

  max-width:320px;

  box-shadow:0 18px 38px rgba(0,0,0,0.5);

  display:flex;

  flex-direction:column;

  gap:14px;

}

.overlay-card h2{

  margin:0;

  font-size:20px;

}

.overlay-card p{

  margin:0;

  font-size:14px;

  color:var(--muted);

}

.control-panel-disabled{

  opacity:0.45;

}

.value-note{

  font-size:11px;

  color:rgba(200,222,255,0.55);

}

.toggle-row{

  display:flex;

  align-items:center;

  gap:8px;

  font-size:13px;

}

.toggle-row input{

  accent-color:var(--chip-green);

}

</style>

</head>

<body>

<div class="app">

  <header class="top-bar">

    <div class="top-left">

      <button class="menu-button" id="sidebarToggle" type="button" aria-expanded="false" aria-controls="sidebarPanel">Menu</button>

    </div>

    <div class="meta">

      <div class="table-meta" id="headerInfo">Blinds: 25 / 50 &bull; Level 1</div>

      <div class="table-meta pot-display" id="potDisplay">Pot: 0</div>

    </div>

  </header>

  <div class="sidebar-backdrop" id="sidebarBackdrop"></div>

  <main class="layout">

    <section class="table-area">

      <div class="table" id="table">

        <div class="table-overlay" id="tableOverlay">

          <div class="overlay-card">

            <h2 id="overlayTitle">Welcome to the Texas Hold'em Tourney v1.1</h2>

            <p id="overlayMessage">Set up your table and start the tournament.</p>

            <div class="welcome-setup setup-panel hidden" id="welcomeSetup">

              <label for="playerName">Player name</label>

              <input type="text" id="playerName" maxlength="18" value="You" placeholder="Enter your name">

              <label for="opponentCount">Opponents <span class="value-pill" id="opponentCountLabel">5</span></label>

              <input type="range" id="opponentCount" min="1" max="7" value="5">

              <label for="startingChips">Starting chips</label>

              <input type="number" id="startingChips" min="500" max="20000" step="100" value="5000">

              <label for="handsPerLevel">Hands per blind level</label>

              <input type="number" id="handsPerLevel" min="2" max="12" step="1" value="5">

              <div class="toggle-row">

                <input type="checkbox" id="autoAdvance" checked>

                <label for="autoAdvance">Auto advance to next hand</label>

              </div>

              <button id="startButton" class="primary">Start Tournament</button>

            </div>

            <button id="overlayButton" class="primary">Start</button>

          </div>

        </div>

        <div class="felt-label">Texas Hold'em at the Golden Players Club</div>

        <div class="community-cards" id="communityCards"></div>

        <div class="chip-layer" id="chipLayer"></div>


        <div class="player-ring" id="playerRing"></div>

      </div>

      <div class="controls panel" id="controlPanel">

        <div class="control-header">

          <span>Your move</span>

          <span id="callInfo">Waiting for the next hand</span>

        </div>

        <div class="control-buttons">

          <button id="foldBtn" class="danger" disabled>Fold</button>

          <button id="checkCallBtn" disabled>Check</button>

          <button id="raiseBtn" class="accent" disabled>Bet / Raise</button>

        </div>

        <div class="slider-row hidden" id="raiseControls">

          <input type="range" id="raiseSlider" min="0" max="0" step="10" value="0">

          <div class="slider-display">Wager: <span id="raiseValue">0</span></div>

          <button id="confirmRaise" class="primary">Confirm</button>

          <button id="raiseIncrement" class="ghost raise-increment">+0</button>

        </div>

        <button id="nextHandButton" class="ghost hidden">Next Hand</button>

      </div>

      <div class="last-hand panel">

        <h2>Last Result</h2>

        <div id="lastResultText">No hands played yet.</div>

      </div>

    </section>

    <aside class="sidebar" id="sidebarPanel">

      <div class="panel menu-panel">

        <h2>Table Menu</h2>

        <p class="menu-note">Use the welcome screen to configure your table.</p>

        <button id="restartButton" class="ghost" disabled>Reset Table</button>

      </div>

      <div class="panel log-panel">

        <h2>Hand Log</h2>

        <div class="log" id="logList"></div>

      </div>

      <div class="panel leaderboard-panel">

        <h2>Leaderboard</h2>

        <ul id="leaderboard"></ul>

      </div>

    </aside>

  </main>

</div>

<script>

(() => {

  'use strict';

  const PLAYER_NAME_LIMIT = 18;

  const RANKS = ['2','3','4','5','6','7','8','9','T','J','Q','K','A'];

  const SUITS = ['c','d','h','s'];

  const SUIT_SYMBOLS = { c:'♣', d:'♦', h:'♥', s:'♠' };

  const RANK_VALUES = { '2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'T':10,'J':11,'Q':12,'K':13,'A':14 };

  const HAND_TITLES = ['High Card','One Pair','Two Pair','Three of a Kind','Straight','Flush','Full House','Four of a Kind','Straight Flush'];

  const STAGE_TITLES = { idle:'Waiting', preflop:'Pre-Flop', flop:'Flop', turn:'Turn', river:'River', showdown:'Showdown' };

  const MOBILE_BREAKPOINT = 1080;

  const BLIND_LEVELS = [

    { small:25, big:50 },

    { small:50, big:100 },

    { small:75, big:150 },

    { small:100, big:200 },

    { small:150, big:300 },

    { small:200, big:400 },

    { small:300, big:600 },

    { small:400, big:800 },

    { small:600, big:1200 },

    { small:800, big:1600 },

    { small:1000, big:2000 }

  ];

  const NAME_POOL = ['Skye','Miles','Tess','Rafi','Mira','Jonah','Selene','Atlas','Nora','Dex','Quinn','Luca','Harper','Callie','Oren','Bex','Jonas','Ada','Kian','Rowan','Sable','Milo','Avery','Kenzo','Lyra','Vera','Finn','Nova','Reese'];

  const FULL_DECK = buildFullDeck();

  const CHIP_DENOMINATIONS = [5000,1000,500,100,50,25,10,5,1];

  const CHIP_ANIMATION_DURATION = 520;


  function getActiveChipDenominations(){



    const cap = Math.max(1, Math.floor((settings.startingChips || 0) * 0.05));



    const allowed = CHIP_DENOMINATIONS.filter(value => value <= cap);



    if(!allowed.includes(1)){



      allowed.push(1);



    }



    return allowed;



  }


  const chipDisplay = {

    anchors:{

      stack:Array(8).fill(null),

      bet:Array(8).fill(null),

      pot:null

    },

    stacks:Array.from({ length:8 }, () => ({ amount:0, chips:[] })),


    bets:Array.from({ length:8 }, () => ({ amount:0, chips:[] })),


    pot:{ amount:0, chips:[] },

    resizeTimer:null,



    resizeListenerAttached:false

  };



  let overlayHandler = null;



  const settings = {
    playerName:'You',
    opponents:5,
    startingChips:5000,
    handsPerLevel:5
  };



  const state = {

    tournamentActive:false,

    players:[],

    deck:[],

    community:[],

    pot:0,

    stage:'idle',

    dealerIndex:-1,

    currentPlayer:-1,

    currentBet:0,

    minRaise:0,

    awaitingAction:false,

    blindLevel:0,

    handsPlayed:0,

    waitingForNextHand:false,

    autoAdvance:true,

    eliminationOrder:[],

    lastResult:null,

    log:[],

    pendingTimeout:null,

    smallBlindIndex:-1,

    bigBlindIndex:-1

  };



  const elements = {

    app:document.querySelector('.app'),

    sidebar:document.getElementById('sidebarPanel'),

    sidebarToggle:document.getElementById('sidebarToggle'),

    sidebarBackdrop:document.getElementById('sidebarBackdrop'),

    playerRing:document.getElementById('playerRing'),



    table:document.getElementById('table'),



    chipLayer:document.getElementById('chipLayer'),

    community:document.getElementById('communityCards'),

    pot:document.getElementById('potDisplay'),

    stage:document.getElementById('stageBadge'),

    headerInfo:document.getElementById('headerInfo'),

    log:document.getElementById('logList'),

    leaderboard:document.getElementById('leaderboard'),

    lastResultText:document.getElementById('lastResultText'),

    overlay:document.getElementById('tableOverlay'),

    overlayTitle:document.getElementById('overlayTitle'),

    overlayMessage:document.getElementById('overlayMessage'),

    overlayButton:document.getElementById('overlayButton'),

    welcomeSetup:document.getElementById('welcomeSetup'),

    controlPanel:document.getElementById('controlPanel'),

    callInfo:document.getElementById('callInfo'),

    foldBtn:document.getElementById('foldBtn'),

    checkCallBtn:document.getElementById('checkCallBtn'),

    raiseBtn:document.getElementById('raiseBtn'),

    raiseControls:document.getElementById('raiseControls'),

    raiseSlider:document.getElementById('raiseSlider'),

    raiseValue:document.getElementById('raiseValue'),

    confirmRaise:document.getElementById('confirmRaise'),

    raiseIncrement:document.getElementById('raiseIncrement'),

    nextHandButton:document.getElementById('nextHandButton'),

    startButton:document.getElementById('startButton'),

    restartButton:document.getElementById('restartButton'),
    
    playerNameInput:document.getElementById('playerName'),

    opponentInput:document.getElementById('opponentCount'),

    opponentLabel:document.getElementById('opponentCountLabel'),

    chipsInput:document.getElementById('startingChips'),

    handsInput:document.getElementById('handsPerLevel'),

    autoAdvance:document.getElementById('autoAdvance')

  };



  function setupChipLayer(){

    if(!elements.chipLayer){

      return;

    }

    const layer = elements.chipLayer;

    layer.innerHTML = '';

    chipDisplay.anchors.stack = [];

    chipDisplay.anchors.bet = [];

    chipDisplay.anchors.pot = null;

    for(let seat=0; seat<8; seat++){

      const stackAnchor = document.createElement('div');

      stackAnchor.className = `chip-anchor stack-anchor stack-${seat}`;

      stackAnchor.dataset.seat = `${seat}`;

      layer.appendChild(stackAnchor);

      chipDisplay.anchors.stack[seat] = stackAnchor;

      const betAnchor = document.createElement('div');

      betAnchor.className = `chip-anchor bet-anchor bet-${seat}`;

      betAnchor.dataset.seat = `${seat}`;

      layer.appendChild(betAnchor);

      chipDisplay.anchors.bet[seat] = betAnchor;

    }

    const potAnchor = document.createElement('div');

    potAnchor.className = 'chip-anchor pot-anchor';

    layer.appendChild(potAnchor);

    chipDisplay.anchors.pot = potAnchor;

    if(!chipDisplay.resizeListenerAttached){

      window.addEventListener('resize', scheduleChipRelayout, { passive:true });

      chipDisplay.resizeListenerAttached = true;

    }

    relayoutStaticChips();

  }



  function scheduleChipRelayout(){

    if(!elements.chipLayer){

      return;

    }

    if(chipDisplay.resizeTimer){

      clearTimeout(chipDisplay.resizeTimer);

    }

    chipDisplay.resizeTimer = setTimeout(() => {

      chipDisplay.resizeTimer = null;

      relayoutStaticChips();

    }, 80);

  }



  function relayoutStaticChips(){

    if(!elements.chipLayer){

      return;

    }

    chipDisplay.stacks.forEach((store, seat) => {

      if(store && store.chips && store.chips.length && chipDisplay.anchors.stack[seat]){

        layoutChipGroup(chipDisplay.anchors.stack[seat], store.chips);

      }

    });

    if(chipDisplay.pot && chipDisplay.pot.chips && chipDisplay.pot.chips.length && chipDisplay.anchors.pot){

      layoutChipGroup(chipDisplay.anchors.pot, chipDisplay.pot.chips, { spread:12, verticalStep:5 });

    }

  }



  function clearChipDisplays(){

    chipDisplay.stacks.forEach(store => {

      if(store && store.chips){

        store.chips.forEach(chip => chip.remove());

      }

    });

    chipDisplay.stacks = Array.from({ length:8 }, () => ({ amount:0, chips:[] }));

    if(chipDisplay.pot && chipDisplay.pot.chips){

      chipDisplay.pot.chips.forEach(chip => chip.remove());

    }

    chipDisplay.pot = { amount:0, chips:[] };

  }



  function resetChipDisplays(){

    if(!elements.chipLayer){

      return;

    }

    if(!chipDisplay.anchors.pot){

      setupChipLayer();

    }

    clearChipDisplays();

    state.players.forEach(player => updateStackDisplay(player));

    const collectedPot = chipDisplay.pot && typeof chipDisplay.pot.amount === 'number'
      ? chipDisplay.pot.amount
      : 0;

    updatePotChips(collectedPot);

    renderPot();

    scheduleChipRelayout();

  }



  function buildChipElements(amount){



    const chips = [];



    let remaining = Math.max(0, Math.round(amount || 0));



    const denominations = getActiveChipDenominations();



    for(const denom of denominations){



      const count = Math.floor(remaining / denom);



      for(let i=0; i<count; i++){



        chips.push(createChipElement(denom));



      }



      remaining -= denom * count;



    }



    return chips;



  }



  function createChipElement(value){

    const chip = document.createElement('div');

    chip.className = `chip ${chipClassFor(value)}`;

    chip.dataset.value = `${value}`;

    chip.dataset.angle = (Math.random() * 26 - 13).toFixed(1);

    const label = formatChipLabel(value);

    chip.innerHTML = `<span class="chip-label">${label}</span>`;

    if(value >= 1000){

      chip.classList.add('chip-small');

    }

    return chip;

  }



  function chipClassFor(value){

    switch(value){

      case 5000: return 'denom-5k';

      case 1000: return 'denom-1k';

      case 500: return 'denom-500';

      case 100: return 'denom-100';

      case 50: return 'denom-50';

      case 25: return 'denom-25';

      case 10: return 'denom-10';

      case 5: return 'denom-5';

      default: return 'denom-1';

    }

  }



  function formatChipLabel(value){

    if(value >= 1000){

      return `${Math.round(value / 1000)}K`;

    }

    return `${value}`;

  }



  function setChipPosition(chip, anchor, index, spread = 8, verticalStep = 4){

    if(!anchor || !chip || !elements.chipLayer){

      return;

    }

    const layerRect = elements.chipLayer.getBoundingClientRect();

    const anchorRect = anchor.getBoundingClientRect();

    const centerX = anchorRect.left - layerRect.left + anchorRect.width / 2;

    const centerY = anchorRect.top - layerRect.top + anchorRect.height / 2;

    const chipSize = chip.offsetWidth || 38;

    const chipRadius = chipSize / 2;

    const sizeRatio = chipSize / 38;

    const adjustedSpread = spread * sizeRatio;

    const adjustedVertical = verticalStep * sizeRatio;

    const offsetX = ((index % 3) - 1) * adjustedSpread;

    const offsetY = -Math.floor(index / 3) * adjustedVertical;

    chip.style.left = `${centerX - chipRadius + offsetX}px`;

    chip.style.top = `${centerY - chipRadius + offsetY}px`;

    const angle = chip.dataset.angle || (Math.random() * 26 - 13).toFixed(1);

    chip.dataset.angle = angle;

    chip.style.transform = `rotate(${angle}deg)`;

  }



  function layoutChipGroup(anchor, chips, options = {}){

    if(!anchor || !chips || !chips.length || !elements.chipLayer){

      return;

    }

    const spread = options.spread ?? 8;

    const verticalStep = options.verticalStep ?? 4;

    chips.forEach(chip => {

      chip.style.transitionDuration = '0ms';

    });

    chips.forEach((chip, idx) => setChipPosition(chip, anchor, idx, spread, verticalStep));

    requestAnimationFrame(() => {

      chips.forEach(chip => {

        chip.style.transitionDuration = '';

      });

    });

  }



  function updateStackDisplay(player, delay = 0){

    if(!player || typeof player.seat !== 'number'){

      return;

    }

    const seat = player.seat;

    const anchor = chipDisplay.anchors.stack[seat];

    if(!anchor){

      return;

    }

    const targetAmount = Math.max(0, Math.round(player.chips || 0));

    const current = chipDisplay.stacks[seat];

    if(!delay && current && current.amount === targetAmount){

      return;

    }

    const apply = () => {

      const store = chipDisplay.stacks[seat];

      if(store && store.chips){

        store.chips.forEach(chip => chip.remove());

      }

      const chips = buildChipElements(targetAmount);

      chips.forEach(chip => elements.chipLayer.appendChild(chip));

      layoutChipGroup(anchor, chips, { spread: seat === 0 ? 10 : 8, verticalStep:4 });

      chipDisplay.stacks[seat] = { amount:targetAmount, chips };

    };

    if(delay){

      setTimeout(apply, delay);

    }else{

      apply();

    }

  }



  function updatePotChips(amount, delay = 0){

    const anchor = chipDisplay.anchors.pot;

    if(!anchor){

      return;

    }

    const targetAmount = Math.max(0, Math.round(amount || 0));

    if(!delay && chipDisplay.pot && chipDisplay.pot.amount === targetAmount){

      return;

    }

    const apply = () => {

      if(chipDisplay.pot.chips){

        chipDisplay.pot.chips.forEach(chip => chip.remove());

      }

      const chips = buildChipElements(targetAmount);

      chips.forEach(chip => elements.chipLayer.appendChild(chip));

      layoutChipGroup(anchor, chips, { spread:12, verticalStep:5 });

      chipDisplay.pot = { amount:targetAmount, chips };

    };

    if(delay){

      setTimeout(apply, delay);

    }else{

      apply();

    }

  }



  function animateChipsBetween(fromAnchor, toAnchor, amount, options = {}){

    if(!elements.chipLayer || !fromAnchor || !toAnchor || !amount){

      if(typeof options.onComplete === 'function'){

        options.onComplete();

      }

      return;

    }

    const chips = buildChipElements(amount);

    if(!chips.length){

      if(typeof options.onComplete === 'function'){

        options.onComplete();

      }

      return;

    }

    const layer = elements.chipLayer;

    const spread = options.spread ?? 8;

    const verticalStep = options.verticalStep ?? 4;

    const duration = options.duration ?? CHIP_ANIMATION_DURATION;

    chips.forEach((chip, idx) => {

      chip.classList.add('chip-floating');

      chip.style.transitionDuration = '0ms';

      layer.appendChild(chip);

      setChipPosition(chip, fromAnchor, idx, spread, verticalStep);

    });

    requestAnimationFrame(() => {

      chips.forEach(chip => {

        chip.style.transitionDuration = `${duration}ms`;

      });

      requestAnimationFrame(() => {

        chips.forEach((chip, idx) => setChipPosition(chip, toAnchor, idx, spread, verticalStep));

      });

    });

    setTimeout(() => {

      chips.forEach(chip => chip.remove());

      if(typeof options.onComplete === 'function'){

        options.onComplete();

      }

    }, duration + 60);

  }



  function animateCommitChips(player, amount, animationOptions){

    if(!player || amount <= 0){

      updateBetDisplay(player);

      return;

    }

    const seatAnchor = chipDisplay.anchors.stack[player.seat];

    const betAnchor = chipDisplay.anchors.bet[player.seat] || seatAnchor;

    if(!seatAnchor || !betAnchor){

      updateBetDisplay(player);

      updateStackDisplay(player);

      return;

    }

    const seatLayout = stackLayoutForSeat(player.seat);

    const betLayout = betLayoutForSeat(player.seat);

    const chips = buildChipElements(amount);

    if(!chips.length){

      updateBetDisplay(player);

      return;

    }

    const duration = animationOptions && animationOptions.kind === 'blind'
      ? Math.max(280, Math.round(CHIP_ANIMATION_DURATION * 0.6))
      : CHIP_ANIMATION_DURATION;

    const layer = elements.chipLayer;

    chips.forEach((chip, idx) => {

      chip.classList.add('chip-floating');

      chip.style.transitionDuration = '0ms';

      layer.appendChild(chip);

      setChipPosition(chip, seatAnchor, idx, seatLayout.spread, seatLayout.verticalStep, seatLayout);

    });

    requestAnimationFrame(() => {

      chips.forEach(chip => { chip.style.transitionDuration = `${duration}ms`; });

      requestAnimationFrame(() => {

        chips.forEach((chip, idx) => setChipPosition(chip, betAnchor, idx, betLayout.spread, betLayout.verticalStep, betLayout));

      });

    });

    setTimeout(() => {

      chips.forEach(chip => chip.remove());

      updateBetDisplay(player);

    }, duration + 60);

    updateStackDisplay(player, duration);

  }



  function animatePotToSeat(player, amount){

    if(!player || amount <= 0){

      updateStackDisplay(player);

      updatePotChips(state.pot);

      return;

    }

    const seatAnchor = chipDisplay.anchors.stack[player.seat];

    const potAnchor = chipDisplay.anchors.pot;

    if(!seatAnchor || !potAnchor){

      updateStackDisplay(player);

      updatePotChips(state.pot);

      return;

    }

    animateChipsBetween(potAnchor, seatAnchor, amount, {

      spread:8,

      verticalStep:4,

      onComplete: () => {

        updateStackDisplay(player);

        updatePotChips(state.pot);

      }

    });

  }






  init();


  function init(){

    setupChipLayer();

    resetChipDisplays();

    if(elements.sidebarToggle){

      elements.sidebarToggle.addEventListener('click', () => toggleSidebar());

    }

    if(elements.sidebarBackdrop){

      elements.sidebarBackdrop.addEventListener('click', () => toggleSidebar(false));

    }

    elements.startButton.addEventListener('click', () => {

      if(state.tournamentActive){

        showOverlay('Restart Tournament?','Starting again will reset this table.','Restart', () => {

          hideOverlay();

          startTournament(true);

        });

      }else{

        hideOverlay();

        startTournament();

      }

    });

    elements.restartButton.addEventListener('click', () => {

      if(state.tournamentActive){

        showOverlay('Reset Table?','This ends the current tournament immediately.','Confirm Reset', () => {

          hideOverlay();

          resetBoard();

        });

      }else{

        resetBoard();

      }

    });

    elements.overlayButton.addEventListener('click', () => {

      if(typeof overlayHandler === 'function'){

        overlayHandler();

      }else{

        hideOverlay();

      }

    });

    if(elements.playerNameInput){

      settings.playerName = normalizePlayerName(elements.playerNameInput.value);

      elements.playerNameInput.value = settings.playerName;

      elements.playerNameInput.addEventListener('input', () => {

        settings.playerName = elements.playerNameInput.value;

      });

      elements.playerNameInput.addEventListener('blur', () => {

        const normalized = normalizePlayerName(elements.playerNameInput.value);

        settings.playerName = normalized;

        elements.playerNameInput.value = normalized;

      });

    }

    elements.opponentInput.addEventListener('input', () => {

      const value = clamp(parseInt(elements.opponentInput.value, 10) || 1, 1, 7);

      settings.opponents = value;

      elements.opponentLabel.textContent = value;

    });

    elements.chipsInput.addEventListener('change', () => {

      const raw = parseInt(elements.chipsInput.value, 10);

      settings.startingChips = clamp(isNaN(raw) ? 5000 : raw, 500, 20000);

      elements.chipsInput.value = settings.startingChips;

    });

    elements.handsInput.addEventListener('change', () => {

      const raw = parseInt(elements.handsInput.value, 10);

      settings.handsPerLevel = clamp(isNaN(raw) ? 5 : raw, 2, 12);

      elements.handsInput.value = settings.handsPerLevel;

    });

    elements.autoAdvance.addEventListener('change', () => {

      state.autoAdvance = !!elements.autoAdvance.checked;

    });

    elements.foldBtn.addEventListener('click', () => handleHumanAction('fold'));

    elements.checkCallBtn.addEventListener('click', () => handleHumanAction('check-call'));

    elements.raiseBtn.addEventListener('click', toggleRaiseControls);

    elements.confirmRaise.addEventListener('click', () => {

      const target = parseInt(elements.raiseSlider.value, 10) || 0;

      handleHumanAction('raise', target);

    });

    elements.raiseSlider.addEventListener('input', updateRaiseValueDisplay);

    if(elements.raiseIncrement){

      elements.raiseIncrement.addEventListener('click', () => {

        incrementRaiseByBigBlind();

      });

    }

    elements.nextHandButton.addEventListener('click', () => {

      if(state.waitingForNextHand){

        clearPendingTimeout();

        startHand();

      }

    });

    showWelcomeModal();

    window.addEventListener('resize', handleResponsiveSidebar);

    renderAll();

    handleResponsiveSidebar();

  }



  function isMobileLayout(){

    return window.innerWidth <= MOBILE_BREAKPOINT;

  }



  function updateSidebarToggle(isOpen){

    if(!elements.sidebarToggle){

      return;

    }

    elements.sidebarToggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');

    elements.sidebarToggle.classList.toggle('active', isOpen);

  }



  function toggleSidebar(forceOpen){

    if(!elements.app || !elements.sidebar){

      return;

    }

    if(!isMobileLayout()){

      elements.app.classList.remove('sidebar-open');

      elements.sidebar.removeAttribute('aria-hidden');

      updateSidebarToggle(false);

      return;

    }

    const shouldOpen = typeof forceOpen === 'boolean'

      ? forceOpen

      : !elements.app.classList.contains('sidebar-open');

    if(shouldOpen){

      elements.app.classList.add('sidebar-open');

      elements.sidebar.removeAttribute('aria-hidden');

    }else{

      elements.app.classList.remove('sidebar-open');

      if(elements.app.classList.contains('sidebar-collapsed')){

        elements.sidebar.setAttribute('aria-hidden','true');

      }else{

        elements.sidebar.removeAttribute('aria-hidden');

      }

    }

    updateSidebarToggle(shouldOpen);

  }



  function handleResponsiveSidebar(){

    if(!elements.app || !elements.sidebar){

      return;

    }

    if(!isMobileLayout()){

      elements.app.classList.remove('sidebar-collapsed');

      toggleSidebar(false);

      return;

    }

    const shouldCollapse = state.tournamentActive;

    elements.app.classList.toggle('sidebar-collapsed', shouldCollapse);

    toggleSidebar(false);

    if(!shouldCollapse){

      elements.sidebar.removeAttribute('aria-hidden');

      updateSidebarToggle(false);

    }

    scheduleChipRelayout();

  }



  function startTournament(force=false){

    if(state.tournamentActive && !force){

      return;

    }

    const heroInputValue = elements.playerNameInput ? elements.playerNameInput.value : settings.playerName;
    const heroName = normalizePlayerName(heroInputValue);
    settings.playerName = heroName;
    if(elements.playerNameInput){
      elements.playerNameInput.value = heroName;
    }

    clearPendingTimeout();

    resetState();

    const totalPlayers = clamp(settings.opponents + 1, 2, 8);

    const seats = generateSeatOrder(totalPlayers);

    const players = [];

    players.push(createPlayer(heroName, true, seats[0], settings.startingChips));

    for(let i=1;i<totalPlayers;i++){

      players.push(createOpponent(seats[i], settings.startingChips));

    }

    state.players = players;

    resetChipDisplays();

    state.tournamentActive = true;

    state.blindLevel = 0;

    state.handsPlayed = 0;

    state.stage = 'idle';

    state.dealerIndex = players.length - 1;

    state.lastResult = null;

    state.log = [];

    state.eliminationOrder = [];

    elements.restartButton.disabled = false;

    disableSetupInputs(true);

    logEvent('Tournament is underway. Good luck!', true);

    startHand();

    handleResponsiveSidebar();

  }



  function resetBoard(){

    resetState();

    state.tournamentActive = false;

    state.players = [];

    state.stage = 'idle';

    resetChipDisplays();

    renderAll();

    disableSetupInputs(false);

    elements.restartButton.disabled = true;

    showWelcomeModal();

    handleResponsiveSidebar();

  }



  function resetState(){

    clearPendingTimeout();

    state.deck = [];

    state.community = [];

    state.pot = 0;

    state.stage = 'idle';

    state.currentBet = 0;

    state.minRaise = 0;

    state.currentPlayer = -1;

    state.awaitingAction = false;

    state.waitingForNextHand = false;

    state.lastResult = null;

    state.log = [];

    state.eliminationOrder = [];

    state.smallBlindIndex = -1;

    state.bigBlindIndex = -1;

  }

  function startHand(){

    const activePlayers = state.players.filter(p => !p.out);

    if(activePlayers.length <= 1){

      finishTournament();

      return;

    }

    clearPendingTimeout();

    state.waitingForNextHand = false;

    elements.nextHandButton.classList.add('hidden');

    state.community = [];

    state.pot = 0;

    state.stage = 'preflop';

    state.currentBet = 0;

    state.minRaise = currentBlinds().big;

    state.players.forEach(player => resetPlayerForHand(player));

    const dealer = nextActiveIndex(state.dealerIndex);

    if(dealer === -1){

      finishTournament();

      return;

    }

    state.dealerIndex = dealer;

    const dealOrder = buildDealOrder(dealer);

    dealHoleCards(dealOrder);

    postBlinds(dealer);

    renderAll();

    updateHeader();

    const firstActor = nextToActAfter(state.bigBlindIndex);

    scheduleNextTurn(firstActor);

    logEvent(`New hand begins. Blinds ${formatChips(currentBlinds().small)} / ${formatChips(currentBlinds().big)}.`);

  }



  function resetPlayerForHand(player){

    if(player.out){

      player.cards = [];

      player.bet = 0;

      player.totalBet = 0;

      player.folded = true;

      player.allIn = false;

      player.hasActed = false;

      player.lastAction = '';

      player.showCards = false;

      player.bestHand = null;

      return;

    }

    player.cards = [];

    player.bet = 0;

    player.totalBet = 0;

    player.folded = false;

    player.allIn = player.chips <= 0;

    player.hasActed = false;

    player.lastAction = '';

    player.showCards = player.isHuman;

    player.bestHand = null;

  }



  function dealHoleCards(order){

    state.deck = buildDeck();

    if(!order.length){

      return;

    }

    for(let round=0; round<2; round++){

      order.forEach(idx => {

        const player = state.players[idx];

        if(player.out) return;

        const card = state.deck.pop();

        if(card){

          player.cards.push(card);

        }

      });

    }

  }



  function postBlinds(dealerIndex){

    const blinds = currentBlinds();

    const active = getActiveIndexes();

    if(active.length < 2){

      state.smallBlindIndex = dealerIndex;

      state.bigBlindIndex = dealerIndex;

      return;

    }

    let dealerPos = active.indexOf(dealerIndex);

    if(dealerPos === -1){

      dealerPos = 0;

    }

    const nextLeft = offset => active[(dealerPos + offset) % active.length];

    let smallIndex;

    let bigIndex;

    if(active.length === 2){

      smallIndex = dealerIndex;

      bigIndex = nextLeft(1);

    }else{

      smallIndex = nextLeft(1);

      bigIndex = nextLeft(2);

    }

    state.smallBlindIndex = smallIndex;

    state.bigBlindIndex = bigIndex;

    postBlind(smallIndex, blinds.small, 'small blind');

    postBlind(bigIndex, blinds.big, 'big blind');

    state.currentBet = Math.max(state.players[smallIndex].bet, state.players[bigIndex].bet);

    state.minRaise = blinds.big;

  }



  function postBlind(index, amount, label){

    const player = state.players[index];

    if(player.chips <= 0){

      player.allIn = true;

      player.hasActed = false;

      return;

    }

    const pay = Math.min(player.chips, amount);

    commitChips(player, pay, { kind:'blind' });

    player.hasActed = false;

    player.lastAction = `Posted ${label} ${formatChips(pay)}`;

    if(player.chips === 0){

      player.allIn = true;

    }

  }



  function scheduleNextTurn(startIndex){

    if(state.waitingForNextHand){

      return;

    }

    const next = findNextToAct(typeof startIndex === 'number' ? startIndex : state.dealerIndex);

    if(next === -1){

      advanceStage();

      return;

    }

    state.currentPlayer = next;

    state.awaitingAction = true;

    const player = state.players[next];

    renderAll();

    if(player.isHuman){

      enableControlsForHuman(player);

    }else{

      disableControls();

      takeAiTurn(next);

    }

  }



  function findNextToAct(startIndex){

    if(!state.players.length) return -1;

    let idx = startIndex;

    if(typeof idx !== 'number' || idx < 0){

      idx = state.dealerIndex;

    }

    for(let i=0; i<state.players.length; i++){

      const current = (idx + i) % state.players.length;

      const player = state.players[current];

      if(player.out || player.folded || player.allIn){

        continue;

      }

      if(!player.hasActed || player.bet !== state.currentBet){

        return current;

      }

    }

    return -1;

  }



  function firstEligiblePlayerAfterDealer(){

    if(!state.players.length){

      return -1;

    }

    for(let offset = 1; offset <= state.players.length; offset++){

      const idx = (state.dealerIndex + offset) % state.players.length;

      const player = state.players[idx];

      if(!player || player.out || player.folded || player.allIn){

        continue;

      }

      return idx;

    }

    return -1;

  }



  function advanceStage(){

    if(state.waitingForNextHand){

      return;

    }

    const active = state.players.filter(p => !p.folded && !p.out);

    if(active.length <= 1){

      handleSingleRemaining(active[0]);

      return;

    }

    if(state.stage === 'river'){

      resolveShowdown();

      return;

    }

    if(state.stage === 'preflop'){

      burnCard();

      dealCommunityCards(3);

      state.stage = 'flop';

      logEvent(`Flop: ${formatCardList(state.community)}`);

    }else if(state.stage === 'flop'){

      burnCard();

      dealCommunityCards(1);

      state.stage = 'turn';

      logEvent(`Turn: ${formatCard(state.community[3])}`);

    }else if(state.stage === 'turn'){

      burnCard();

      dealCommunityCards(1);

      state.stage = 'river';

      logEvent(`River: ${formatCard(state.community[4])}`);

    }else{

      resolveShowdown();

      return;

    }

    resetRoundBets();

    renderAll();

    const first = firstEligiblePlayerAfterDealer();

    if(first === -1){

      advanceStage();

      return;

    }

    scheduleNextTurn(first);

  }



  function resetRoundBets(){

    state.currentBet = 0;

    state.minRaise = Math.max(currentBlinds().big, 20);

    state.players.forEach(player => {

      if(player.out) return;

      player.bet = 0;

      if(!player.allIn && !player.folded){

        player.hasActed = false;

      }

    });

  }



  function burnCard(){

    if(state.deck.length){

      state.deck.pop();

    }

  }



  function dealCommunityCards(count){

    for(let i=0; i<count; i++){

      const card = state.deck.pop();

      if(card){

        state.community.push(card);

      }

    }

  }



  function handleHumanAction(type, targetTotal){

    const player = state.players[state.currentPlayer];

    if(!player || !player.isHuman || state.waitingForNextHand){

      return;

    }

    if(type === 'fold'){

      applyAction(player, { kind:'fold' });

      return;

    }

    if(type === 'check-call'){

      const callAmount = Math.max(0, state.currentBet - player.bet);

      if(callAmount <= 0){

        applyAction(player, { kind:'check' });

      }else{

        applyAction(player, { kind:'call' });

      }

      return;

    }

    if(type === 'raise'){

      const total = clamp(targetTotal || 0, player.bet, player.bet + player.chips);

      applyAction(player, { kind:'raise', total });

      elements.raiseControls.classList.add('hidden');

    }

  }



  function toggleRaiseControls(){

    if(elements.raiseControls.classList.contains('hidden')){

      setupRaiseSlider();

      elements.raiseControls.classList.remove('hidden');

    }else{

      elements.raiseControls.classList.add('hidden');

    }

  }



  function updateRaiseValueDisplay(){

    if(!elements.raiseSlider || !elements.raiseValue){

      return;

    }

    const slider = elements.raiseSlider;

    const rawValue = parseInt(slider.value, 10) || 0;

    elements.raiseValue.textContent = formatChips(rawValue);

    if(elements.raiseIncrement){

      const max = parseInt(slider.max, 10);

      const baseDisabled = elements.raiseIncrement.dataset.incrementDisabled === 'true';

      const atCap = Number.isFinite(max) && rawValue >= max;

      elements.raiseIncrement.disabled = baseDisabled || atCap;

    }

  }



  function incrementRaiseByBigBlind(){

    if(!elements.raiseSlider){

      return;

    }

    const slider = elements.raiseSlider;

    const bigBlind = currentBlinds().big || 0;

    if(bigBlind <= 0){

      return;

    }

    const currentValue = parseInt(slider.value, 10) || 0;

    const max = parseInt(slider.max, 10);

    const min = parseInt(slider.min, 10);

    const step = parseInt(slider.step, 10) || 1;

    const upperBound = Number.isFinite(max) ? max : currentValue + bigBlind;

    const lowerBound = Number.isFinite(min) ? min : 0;

    const target = Math.min(upperBound, currentValue + bigBlind);

    const aligned = Math.max(lowerBound, Math.min(upperBound, Math.ceil(target / step) * step));

    slider.value = aligned;

    updateRaiseValueDisplay();

  }



  function setupRaiseSlider(){

    const player = state.players[state.currentPlayer];

    if(!player || !elements.raiseSlider){

      return;

    }

    const slider = elements.raiseSlider;

    const callAmount = Math.max(0, state.currentBet - player.bet);

    const minTotal = determineMinRaiseTotal(player);

    const maxTotal = player.bet + player.chips;

    const sliderMin = Math.max(minTotal, player.bet + callAmount);

    slider.min = sliderMin;

    slider.max = maxTotal;

    const blinds = currentBlinds();

    const bigBlind = blinds.big || 0;

    slider.step = Math.max(5, Math.floor(bigBlind / 2));

    slider.value = clamp(minTotal, sliderMin, maxTotal);

    if(elements.raiseIncrement){

      elements.raiseIncrement.textContent = `+${formatChips(bigBlind)}`;

      elements.raiseIncrement.dataset.incrementDisabled = bigBlind <= 0 ? 'true' : 'false';

    }

    updateRaiseValueDisplay();

  }



  function determineMinRaiseTotal(player){

    const callAmount = Math.max(0, state.currentBet - player.bet);

    if(state.currentBet === 0){

      return player.bet + Math.min(player.chips, Math.max(currentBlinds().big, 20));

    }

    const base = state.currentBet + Math.max(state.minRaise, currentBlinds().big);

    return Math.min(player.bet + player.chips, base);

  }



  function applyAction(player, action){

    const index = state.players.indexOf(player);

    if(index === -1 || state.waitingForNextHand){

      return;

    }

    disableControls();

    switch(action.kind){

      case 'fold':

        player.folded = true;

        player.hasActed = true;

        player.lastAction = 'Folds';

        logEvent(`${player.name} folds.`);

        break;

      case 'check':

        player.hasActed = true;

        player.lastAction = 'Checks';

        logEvent(`${player.name} checks.`);

        break;

      case 'call': {

        const toCall = Math.max(0, state.currentBet - player.bet);

        const amount = Math.min(player.chips, toCall);

        if(amount > 0){

          commitChips(player, amount, { kind:'bet' });

        }

        player.hasActed = true;

        if(amount < toCall){

          player.allIn = true;

          player.lastAction = `Calls all-in for ${formatChips(amount)}`;

          logEvent(`${player.name} calls all-in for ${formatChips(amount)}.`);

        }else if(amount === 0){

          player.lastAction = 'Checks';

          logEvent(`${player.name} checks.`);

        }else{

          player.lastAction = `Calls ${formatChips(amount)}`;

          logEvent(`${player.name} calls ${formatChips(amount)}.`);

        }

        break;

      }

      case 'raise': {

        const previousBet = state.currentBet;

        let targetTotal = clamp(action.total || previousBet, player.bet, player.bet + player.chips);

        if(targetTotal <= previousBet){

          const toCall = Math.max(0, previousBet - player.bet);

          const amount = Math.min(player.chips, toCall);

          if(amount > 0){

            commitChips(player, amount, { kind:'bet' });

          }

          player.hasActed = true;

          player.lastAction = amount < toCall ? `Calls all-in for ${formatChips(amount)}` : `Calls ${formatChips(amount)}`;

          logEvent(`${player.name} calls ${formatChips(amount)}.`);

          break;

        }

        const raiseAmount = targetTotal - player.bet;

        commitChips(player, raiseAmount, { kind:'bet' });

        player.hasActed = true;

        state.minRaise = Math.max(currentBlinds().big, targetTotal - previousBet);

        state.currentBet = player.bet;

        player.lastAction = `Raises to ${formatChips(player.bet)}`;

        logEvent(`${player.name} raises to ${formatChips(player.bet)}.`);

        state.players.forEach((other, idx) => {

          if(idx !== index && !other.folded && !other.allIn && !other.out){

            other.hasActed = false;

          }

        });

        break;

      }

    }

    renderAll();

    if(state.waitingForNextHand){

      return;

    }

    if(handleSingleRemaining()){

      return;

    }

    const next = findNextToAct(index + 1);

    if(next === -1){

      advanceStage();

    }else{

      scheduleNextTurn(next);

    }

  }



  function handleSingleRemaining(forcedWinner){

    const contenders = state.players.filter(p => !p.folded && !p.out);

    if(contenders.length === 1){

      const winner = forcedWinner || contenders[0];

      const uncontestedAmount = state.pot;

      winner.chips += uncontestedAmount;

      const uncontestedDescriptor = 'an uncontested pot';

      recordHandOutcome([
        { name:winner.name, amount:uncontestedAmount, hand:uncontestedDescriptor }
      ], uncontestedDescriptor);

      if(uncontestedAmount > 0){

        state.pot = Math.max(0, state.pot - uncontestedAmount);

        updatePotChips(state.pot);

        renderPot();

        animatePotToSeat(winner, uncontestedAmount);

      }else{

        updateStackDisplay(winner);

        updatePotChips(state.pot);

        renderPot();

      }

      state.pot = 0;

      finishHand();

      return true;

    }

    return false;

  }



  function resolveShowdown(){

    state.stage = 'showdown';

    const contenders = state.players.filter(p => !p.folded && !p.out);

    if(!contenders.length){

      finishHand();

      return;

    }

    const pots = buildPots();

    const payoutsByPlayer = new Map();
    const handByPlayer = new Map();

    let animatedPayout = false;

    pots.forEach(pot => {

      const evaluated = pot.eligible.map(idx => {

        const player = state.players[idx];

        const hand = evaluateBestHand(player.cards.concat(state.community));

        player.bestHand = hand;

        player.showCards = true;

        return { player, hand };

      });

      if(!evaluated.length){

        return;

      }

      evaluated.sort((a,b) => compareScores(b.hand.score, a.hand.score));

      const bestScore = evaluated[0].hand.score;

      const winners = evaluated.filter(entry => compareScores(entry.hand.score, bestScore) === 0).map(entry => entry.player);

      const share = Math.floor(pot.amount / winners.length);

      const remainder = pot.amount % winners.length;

      winners.forEach((winner, idx) => {

        const payout = share + (idx < remainder ? 1 : 0);

        winner.chips += payout;

        payoutsByPlayer.set(winner.name, (payoutsByPlayer.get(winner.name) || 0) + payout);

        if(!handByPlayer.has(winner.name)){

          const handName = winner.bestHand && winner.bestHand.name ? winner.bestHand.name : evaluated[0].hand.name;

          handByPlayer.set(winner.name, handName);

        }

        if(payout > 0){

          state.pot = Math.max(0, state.pot - payout);

          updatePotChips(state.pot);

          renderPot();

          animatePotToSeat(winner, payout);

          animatedPayout = true;

        }else{

          updateStackDisplay(winner);

        }

      });

    });

    if(payoutsByPlayer.size){

      const aggregated = Array.from(payoutsByPlayer.entries()).map(([name, amount]) => ({

        name,

        amount,

        hand:handByPlayer.get(name) || ''

      }));

      recordHandOutcome(aggregated);

    }else{

      state.lastResult = null;

    }

    if(!animatedPayout){

      updatePotChips(state.pot);

    }

    state.pot = 0;

    finishHand();

  }



  function buildPots(){

    const contributions = state.players.map((player, idx) => ({

      index:idx,

      amount:player.totalBet,

      folded:player.folded || player.out

    }));

    const pots = [];

    while(true){

      const active = contributions.filter(c => c.amount > 0);

      if(!active.length){

        break;

      }

      const min = Math.min(...active.map(c => c.amount));

      const participants = [];

      active.forEach(entry => {

        entry.amount -= min;

        participants.push(entry.index);

      });

      const amount = min * active.length;

      const eligible = participants.filter(idx => {

        const player = state.players[idx];

        return !player.folded && !player.out;

      });

      pots.push({ amount, eligible });

    }

    return pots;

  }



  function finishHand(){

    state.awaitingAction = false;

    state.waitingForNextHand = true;

    state.players.forEach(player => {

      player.bet = 0;

      player.hasActed = false;

    });

    markEliminations();

    renderAll();

    updateHeader();

    if(checkForChampion()){

      return;

    }

    elements.nextHandButton.classList.remove('hidden');

    state.handsPlayed += 1;

    maybeAdvanceBlinds();

    if(state.autoAdvance){

      state.pendingTimeout = setTimeout(() => {

        if(state.waitingForNextHand){

          startHand();

        }

      }, 2600);

    }

  }



  function checkForChampion(){

    const remaining = state.players.filter(p => !p.out);

    if(remaining.length === 1){

      const champ = remaining[0];

      state.tournamentActive = false;

      disableControls();

      disableSetupInputs(false);

      elements.restartButton.disabled = true;

      const message = champ.isHuman ? `${champ.name} takes down the tournament and claims all the chips.` : `${champ.name} takes the final pot.`;

      showOverlay('Champion Crowned', message, 'Play Again', () => {

        hideOverlay();

        resetBoard();

      });

      return true;

    }

    return false;

  }



  function markEliminations(){

    state.players.forEach(player => {

      if(!player.out && player.chips <= 0){

        player.out = true;

        player.folded = true;

        player.cards = [];

        const place = state.players.length - state.eliminationOrder.length;

        state.eliminationOrder.push(player);

        logEvent(`${player.name} is eliminated in ${ordinal(place)} place.`);

      }

    });

  }



  function maybeAdvanceBlinds(){

    if(state.handsPlayed % settings.handsPerLevel === 0 && state.blindLevel < BLIND_LEVELS.length - 1){

      state.blindLevel += 1;

      logEvent(`Blinds increase to ${formatChips(currentBlinds().small)} / ${formatChips(currentBlinds().big)}.`, true);

    }

  }



  function finishTournament(){

    renderAll();

    disableControls();

    disableSetupInputs(false);

    state.tournamentActive = false;

    handleResponsiveSidebar();

  }

  async function takeAiTurn(index){

    const player = state.players[index];

    if(!player || player.isHuman || state.waitingForNextHand){

      return;

    }

    const isOutOfHand = player.folded || player.out || player.allIn;

    const thinkTime = isOutOfHand ? 200 : (500 + Math.random() * 1500);

    await sleep(thinkTime);

    if(player.folded || player.out || player.allIn || state.waitingForNextHand){

      scheduleNextTurn(index + 1);

      return;

    }

    const callAmount = Math.max(0, state.currentBet - player.bet);

    const canRaise = player.chips + player.bet > state.currentBet;

    const strength = await estimateWinChance(index);

    const looseness = player.style.looseness;

    const aggression = player.style.aggression;

    const bluffFactor = player.style.bluff;

    let action = { kind:'check' };

    if(callAmount === 0){

      if(player.chips === 0){

        action = { kind:'check' };

      }else{

        const willing = strength + (Math.random() * looseness);

        if(willing > 0.65){

          const total = pickRaiseTotal(player, strength, aggression, 1.4);

          action = { kind:'raise', total };

        }else if(willing > 0.45 && Math.random() < (looseness + bluffFactor) * 0.6){

          const total = pickRaiseTotal(player, Math.max(0.45, strength), aggression, 0.9);

          action = { kind:'raise', total };

        }else{

          action = { kind:'check' };

        }

      }

    }else{

      const potOdds = callAmount > 0 ? callAmount / (state.pot + callAmount) : 0;

      const threshold = Math.max(0.18, potOdds * (0.9 - looseness*0.4));

      if(strength < threshold && Math.random() > looseness + 0.1){

        action = { kind:'fold' };

      }else if(canRaise && strength > 0.62 + looseness*0.15){

        const total = pickRaiseTotal(player, strength, aggression, 1.2);

        if(total > state.currentBet){

          action = { kind:'raise', total };

        }else{

          action = { kind:'call' };

        }

      }else if(canRaise && Math.random() < bluffFactor * 0.2 && state.pot < player.chips * 2){

        const total = pickRaiseTotal(player, 0.5, aggression * 0.8, 0.7);

        action = { kind:'raise', total };

      }else{

        action = { kind:'call' };

      }

    }

    applyAction(player, action);

  }



  function pickRaiseTotal(player, strength, aggression, scale){

    const callAmount = Math.max(0, state.currentBet - player.bet);

    let target;

    if(state.currentBet === 0){

      target = player.bet + Math.min(player.chips, Math.max(currentBlinds().big, Math.round(currentBlinds().big * (1.5 + aggression*0.5))));

    }else{

      const base = state.currentBet + Math.max(state.minRaise, currentBlinds().big);

      const multiplier = 1 + (strength - 0.5) * (1.5 * aggression);

      target = base + Math.round((state.pot + callAmount) * multiplier * 0.35 * scale);

      target = Math.max(base, target);

    }

    target = Math.min(player.bet + player.chips, target);

    target = Math.max(player.bet + callAmount, target);

    return Math.max(target, player.bet + Math.min(player.chips, Math.max(currentBlinds().big, 20)));

  }



  async function estimateWinChance(index){

    const hero = state.players[index];

    const opponents = state.players.filter((p, idx) => idx !== index && !p.folded && !p.out);

    if(!opponents.length){

      return 1;

    }

    const known = hero.cards.concat(state.community);

    const remaining = FULL_DECK.filter(card => !containsCard(known, card));

    const missingBoard = 5 - state.community.length;

    const samples = state.community.length < 3 ? 140 : 90;

    let score = 0;

    for(let i=0; i<samples; i++){

      shuffleInPlace(remaining);

      const deck = remaining.slice();

      const board = state.community.slice();

      let pointer = 0;

      for(let b=0; b<missingBoard; b++){

        board.push(deck[pointer++]);

      }

      const oppHands = opponents.map(() => [deck[pointer++], deck[pointer++]]);

      const heroHand = evaluateBestHand(hero.cards.concat(board));

      let bestScore = heroHand.score;

      let winners = [heroHand];

      for(let j=0; j<oppHands.length; j++){

        const hand = evaluateBestHand(oppHands[j].concat(board));

        const cmp = compareScores(hand.score, bestScore);

        if(cmp > 0){

          bestScore = hand.score;

          winners = [hand];

        }else if(cmp === 0){

          winners.push(hand);

        }

      }

      if(compareScores(heroHand.score, bestScore) === 0){

        score += 1 / winners.length;

      }

    }

    return score / samples;

  }



  function enableControlsForHuman(player){

    elements.controlPanel.classList.remove('control-panel-disabled');

    const callAmount = Math.max(0, state.currentBet - player.bet);

    const toCall = Math.min(player.chips, callAmount);

    elements.foldBtn.disabled = false;

    elements.checkCallBtn.disabled = false;

    elements.callInfo.textContent = callAmount > 0 ? `Call ${formatChips(callAmount)}` : 'Check or bet';

    elements.checkCallBtn.textContent = callAmount > 0 ? (toCall < callAmount ? 'Call (All-In)' : `Call ${formatChips(callAmount)}`) : 'Check';

    const canRaise = player.chips + player.bet > state.currentBet && player.chips > 0;

    elements.raiseBtn.disabled = !canRaise;

    if(!canRaise){

      elements.raiseControls.classList.add('hidden');

    }

    state.awaitingAction = true;

  }



  function disableControls(){

    elements.foldBtn.disabled = true;

    elements.checkCallBtn.disabled = true;

    elements.raiseBtn.disabled = true;

    elements.raiseControls.classList.add('hidden');

    elements.controlPanel.classList.add('control-panel-disabled');

    elements.callInfo.textContent = state.waitingForNextHand ? 'Waiting for next hand' : 'Opponent acting';

  }



  function commitChips(player, amount, animationOptions){

    const payment = Math.min(player.chips, amount);

    if(payment <= 0){

      if(animationOptions && animationOptions.kind === 'blind' && player){

        updateStackDisplay(player);

      }

      return;

    }

    player.chips -= payment;

    player.bet += payment;

    player.totalBet += payment;

    state.pot += payment;

    renderPot();

    if(player.chips === 0){

      player.allIn = true;

    }

    animateCommitChips(player, payment, animationOptions);

  }



  function currentBlinds(){

    return BLIND_LEVELS[state.blindLevel] || BLIND_LEVELS[BLIND_LEVELS.length - 1];

  }



  function getActiveIndexes(){

    const list = [];

    state.players.forEach((player, idx) => {

      if(!player.out){

        list.push(idx);

      }

    });

    return list;

  }



  function buildDealOrder(dealerIndex){

    const active = getActiveIndexes();

    if(!active.length){

      return [];

    }

    let dealerPos = active.indexOf(dealerIndex);

    if(dealerPos === -1){

      dealerPos = 0;

    }

    const order = [];

    for(let i=1; i<=active.length; i++){

      order.push(active[(dealerPos + i) % active.length]);

    }

    return order;

  }



  function nextActiveIndex(start){

    if(!state.players.length) return -1;

    for(let i=1; i<=state.players.length; i++){

      const idx = (start + i) % state.players.length;

      const player = state.players[idx];

      if(!player.out){

        return idx;

      }

    }

    return -1;

  }



  function nextToActAfter(index){

    if(typeof index !== 'number' || index < 0){

      index = state.dealerIndex;

    }

    return findNextToAct(index + 1);

  }



  function generateSeatOrder(count){

    const seatClockwiseOrder = [0,1,2,3,4,5,6,7];

    const fillOrder = [4,3,5,2,6,1,7];

    if(count <= 1){

      return [0];

    }

    const seats = [0];

    const needed = Math.min(fillOrder.length, Math.max(0, count - 1));

    for(let i=0; i<needed; i++){

      seats.push(fillOrder[i]);

    }

    if(seats.length < count){

      const remaining = seatClockwiseOrder.filter(seat => !seats.includes(seat));

      seats.push(...remaining.slice(0, count - seats.length));

    }

    const unique = Array.from(new Set(seats)).slice(0, count);

    unique.sort((a, b) => seatClockwiseOrder.indexOf(a) - seatClockwiseOrder.indexOf(b));

    return unique;

  }



  function createPlayer(name, isHuman, seat, chips){

    return {

      id:`${isHuman ? 'H' : 'A'}${seat}`,

      name,

      seat,

      isHuman,

      chips,

      cards:[],

      bet:0,

      totalBet:0,

      folded:false,

      allIn:false,

      hasActed:false,

      out:false,

      style:isHuman ? null : buildStyleProfile(),

      lastAction:'',

      showCards:isHuman,

      bestHand:null

    };

  }



  function createOpponent(seat, chips){

    return createPlayer(pickOpponentName(), false, seat, chips);

  }



  function buildStyleProfile(){

    return {

      aggression:0.65 + Math.random()*0.5,

      looseness:0.08 + Math.random()*0.28,

      bluff:0.1 + Math.random()*0.25

    };

  }



  let nameCursor = 0;

  function pickOpponentName(){

    const name = NAME_POOL[nameCursor % NAME_POOL.length];

    nameCursor += 1;

    return name;

  }



  function renderAll(){

    renderPlayers();

    renderCommunity();

    renderPot();

    renderStage();

    renderLog();

    renderLeaderboard();

    renderLastResult();

  }

  function renderPlayers(){

    const container = elements.playerRing;

    container.innerHTML = '';

    const seatsUsed = new Set(state.players.map(p => p.seat));

    for(let seat=0; seat<8; seat++){

      const player = state.players.find(p => p.seat === seat);

      const seatEl = document.createElement('div');

      seatEl.className = `seat seat-${seat}`;

      if(player){

        const idx = state.players.indexOf(player);

        seatEl.classList.add(player.isHuman ? 'human' : 'ai');

        if(player.folded) seatEl.classList.add('folded');

        if(player.allIn) seatEl.classList.add('all-in');

        if(player.out) seatEl.classList.add('out');

        if(idx === state.currentPlayer && !state.waitingForNextHand){

          seatEl.classList.add('active');

        }





        const nameEl = document.createElement('div');

        nameEl.className = 'name';

        nameEl.textContent = player.name;

        seatEl.appendChild(nameEl);

        if(state.dealerIndex === idx){
          const dealerBadge = document.createElement('div');
          dealerBadge.className = 'dealer-badge';
          dealerBadge.textContent = 'D';
          nameEl.appendChild(dealerBadge);
        }

        const chipEl = document.createElement('div');

        chipEl.className = 'chip-count';

        chipEl.textContent = player.out ? 'Eliminated' : `${formatChips(player.chips)} chips`;

        seatEl.appendChild(chipEl);

        const statusEl = document.createElement('div');

        statusEl.className = 'status';

        let statusText = '';

        if(player.out){

          statusText = '';

        }else if(player.folded){

          statusText = 'Folded';

        }else if(player.allIn){

          statusText = 'All-in';

        }else if(player.lastAction){

          statusText = player.lastAction;

        }

        statusEl.textContent = statusText;

        seatEl.appendChild(statusEl);

        const cardsRow = document.createElement('div');

        cardsRow.className = 'card-row';

        const reveal = player.isHuman || player.showCards || state.stage === 'showdown';

        if(player.cards.length){

          player.cards.slice(0,2).forEach(card => {

            cardsRow.appendChild(renderCard(reveal ? card : null));

          });

        }else{

          cardsRow.appendChild(renderCard(null));

          cardsRow.appendChild(renderCard(null));

        }

        seatEl.appendChild(cardsRow);

      }else if(seatsUsed.has(seat)){

        continue;

      }

      container.appendChild(seatEl);

    }

  }



  function renderCard(card){

    const cardEl = document.createElement('div');

    cardEl.className = 'card';

    if(!card){

      cardEl.classList.add('back');

      cardEl.textContent = 'GPC';

      return cardEl;

    }

    const suitSymbol = SUIT_SYMBOLS[card.suit] || '';

    const rankLabel = card.rank === 'T' ? '10' : card.rank;

    if(card.suit === 'h' || card.suit === 'd'){

      cardEl.classList.add('red');

    }

    const top = document.createElement('div');

    top.className = 'corner';

    top.innerHTML = `<span>${rankLabel}</span><span class="suit">${suitSymbol}</span>`;

    const bottom = document.createElement('div');

    bottom.className = 'corner bottom';

    bottom.innerHTML = `<span>${rankLabel}</span><span class="suit">${suitSymbol}</span>`;

    cardEl.appendChild(top);

    cardEl.appendChild(bottom);

    return cardEl;

  }



  function renderCommunity(){

    const wrapper = elements.community;

    wrapper.innerHTML = '';

    state.community.forEach(card => {

      wrapper.appendChild(renderCard(card));

    });

  }



  function renderPot(){

    elements.pot.textContent = `Pot: ${formatChips(state.pot)}`;

  }



  function renderStage(){

    if(!elements.stage){

      return;

    }

    const label = STAGE_TITLES[state.stage] || 'Waiting';

    elements.stage.textContent = label;

  }



  function renderLog(){

    const logEl = elements.log;

    logEl.innerHTML = '';

    state.log.slice(-120).forEach(entry => {

      const div = document.createElement('div');

      div.className = 'log-item';

      if(entry.highlight) div.classList.add('highlight');

      if(entry.type === 'win') div.classList.add('win');

      div.textContent = entry.text;

      logEl.appendChild(div);

    });

    logEl.scrollTop = logEl.scrollHeight;

  }



  function renderLeaderboard(){

    const list = elements.leaderboard;

    list.innerHTML = '';

    if(!state.players.length){

      return;

    }

    const sorted = [...state.players].sort((a,b) => b.chips - a.chips);

    sorted.forEach(player => {

      const li = document.createElement('li');

      const name = document.createElement('span');

      name.textContent = player.name + (player.out ? ' (out)' : '');

      const stack = document.createElement('span');

      stack.textContent = player.out ? '-' : formatChips(player.chips);

      li.appendChild(name);

      li.appendChild(stack);

      list.appendChild(li);

    });

  }



  function renderLastResult(){

    const result = state.lastResult;

    if(!result || !Array.isArray(result.payouts) || result.payouts.length === 0){

      elements.lastResultText.textContent = 'No hands played yet.';

      return;

    }

    const payouts = result.payouts;

    if(payouts.length === 1){

      const entry = payouts[0];

      const suffix = result.description ? ` with ${result.description}.` : '.';

      elements.lastResultText.innerHTML = `<strong>${entry.name}</strong> won ${formatChips(entry.amount)}${suffix}`;

      return;

    }

    const formatted = payouts.map(entry => `<strong>${entry.name}</strong> (${formatChips(entry.amount)})`);

    const winnersText = joinWithAnd(formatted);

    const suffix = result.description ? ` with ${result.description}.` : '.';

    elements.lastResultText.innerHTML = `${winnersText} collected the pot${suffix}`;

  }



  function logEvent(text, highlight=false){

    state.log.push({ text, highlight });

  }



  function joinWithAnd(parts){

    if(!parts || parts.length === 0){

      return '';

    }

    if(parts.length === 1){

      return parts[0];

    }

    if(parts.length === 2){

      return `${parts[0]} and ${parts[1]}`;

    }

    const head = parts.slice(0, -1).join(', ');

    const tail = parts[parts.length - 1];

    return `${head}, and ${tail}`;

  }



  function recordHandOutcome(payouts, description){

    const normalized = (payouts || []).map(entry => ({

      name:entry.name,

      amount:Math.max(0, Math.round(entry.amount || 0)),

      hand:entry.hand || ''

    })).filter(entry => entry.name);



    if(!normalized.length){

      state.lastResult = null;

      return;

    }



    normalized.sort((a, b) => {

      if(b.amount !== a.amount){

        return b.amount - a.amount;

      }

      return a.name.localeCompare(b.name);

    });



    const handNames = normalized
      .map(entry => entry.hand)
      .filter(hand => hand && hand.length > 0);
    const uniformHand = handNames.length > 0 && handNames.every(hand => hand === handNames[0]) ? handNames[0] : '';
    const primaryDescription = description || uniformHand;



    state.lastResult = {

      payouts:normalized,

      description:primaryDescription

    };



    let message;
    if(normalized.length === 1){
      const winner = normalized[0];
      const suffixDesc = primaryDescription || winner.hand;
      const suffix = suffixDesc ? ` with ${suffixDesc}.` : '.';
      message = `${winner.name} wins ${formatChips(winner.amount)}${suffix}`;
    }else{
      const listForLog = normalized.map(entry => `${entry.name} (${formatChips(entry.amount)})`);
      const logSummary = joinWithAnd(listForLog);
      const suffix = primaryDescription ? ` with ${primaryDescription}.` : '.';
      message = `${logSummary} collect the pot${suffix}`;
    }

    logEvent(message, true);

  }



  function updateHeader(){

    const blinds = currentBlinds();

    elements.headerInfo.textContent = `Blinds: ${formatChips(blinds.small)} / ${formatChips(blinds.big)} \u2022 Level ${state.blindLevel + 1}`;

  }



  function setOverlayMode(mode){
    if(!elements.welcomeSetup || !elements.overlayButton){
      return;
    }
    if(mode === 'welcome'){
      elements.welcomeSetup.classList.remove('hidden');
      elements.overlayButton.classList.add('hidden');
    }else{
      elements.welcomeSetup.classList.add('hidden');
      elements.overlayButton.classList.remove('hidden');
    }
  }

  function normalizePlayerName(name){
    const trimmed = (name || '').replace(/\s+/g, ' ').trim();
    if(!trimmed){
      return 'You';
    }
    return trimmed.slice(0, PLAYER_NAME_LIMIT);
  }

  function showOverlay(title, message, buttonLabel, handler){
    setOverlayMode('message');

    elements.overlayTitle.textContent = title;

    elements.overlayMessage.textContent = message;

    elements.overlayButton.textContent = buttonLabel || 'OK';

    elements.overlay.classList.remove('hidden');

    overlayHandler = handler;

  }


  function showWelcomeModal(){
    setOverlayMode('welcome');

    const currentName = normalizePlayerName(settings.playerName);
    settings.playerName = currentName;

    if(elements.playerNameInput){
      elements.playerNameInput.value = currentName;
    }

    if(elements.opponentInput){
      elements.opponentInput.value = settings.opponents;
    }

    if(elements.opponentLabel){
      elements.opponentLabel.textContent = settings.opponents;
    }

    if(elements.chipsInput){
      elements.chipsInput.value = settings.startingChips;
    }

    if(elements.handsInput){
      elements.handsInput.value = settings.handsPerLevel;
    }

    if(elements.autoAdvance){
      elements.autoAdvance.checked = !!state.autoAdvance;
    }

    elements.overlayTitle.textContent = 'Welcome';
    elements.overlayMessage.textContent = 'Set up your table and start the tournament.';
    toggleSidebar(false);
    elements.overlay.classList.remove('hidden');
    overlayHandler = null;
  }


  function hideOverlay(){

    elements.overlay.classList.add('hidden');

    overlayHandler = null;

  }



  function disableSetupInputs(flag){

    if(elements.playerNameInput){
      elements.playerNameInput.disabled = flag;
    }

    elements.opponentInput.disabled = flag;

    elements.chipsInput.disabled = flag;

    elements.handsInput.disabled = flag;

    elements.autoAdvance.disabled = flag;

  }



  function sleep(ms){

    return new Promise(resolve => setTimeout(resolve, ms));

  }



  function buildDeck(){

    const copy = FULL_DECK.map(card => ({ ...card }));

    shuffleInPlace(copy);

    return copy;

  }



  function buildFullDeck(){

    const deck = [];

    SUITS.forEach(suit => {

      RANKS.forEach(rank => {

        deck.push({ rank, suit, value:RANK_VALUES[rank], code:rank + suit });

      });

    });

    return deck;

  }



  function shuffleInPlace(array){

    for(let i=array.length -1; i>0; i--){

      const j = Math.floor(Math.random() * (i+1));

      [array[i], array[j]] = [array[j], array[i]];

    }

    return array;

  }



  function evaluateBestHand(cards){

    const total = cards.length;

    let best = null;

    let bestScore = null;

    for(let a=0; a<total-4; a++){

      for(let b=a+1; b<total-3; b++){

        for(let c=b+1; c<total-2; c++){

          for(let d=c+1; d<total-1; d++){

            for(let e=d+1; e<total; e++){

              const combo = [cards[a], cards[b], cards[c], cards[d], cards[e]];

              const result = evaluateFive(combo);

              if(!bestScore || compareScores(result.score, bestScore) > 0){

                best = result;

                bestScore = result.score;

              }

            }

          }

        }

      }

    }

    return best;

  }



  function evaluateFive(cards){

    const counts = {};

    const suits = {};

    const values = [];

    cards.forEach(card => {

      counts[card.value] = (counts[card.value] || 0) + 1;

      suits[card.suit] = (suits[card.suit] || 0) + 1;

      values.push(card.value);

    });

    values.sort((a,b) => b - a);

    const grouped = Object.entries(counts).map(([value, count]) => ({

      value:parseInt(value, 10),

      count

    })).sort((a,b) => {

      if(b.count !== a.count) return b.count - a.count;

      return b.value - a.value;

    });

    const isFlush = Object.values(suits).some(count => count === 5);

    const straightHigh = detectStraight(values);

    let category = 0;

    let kickers = [];

    if(isFlush && straightHigh){

      category = 8;

      kickers = [straightHigh];

    }else if(grouped[0].count === 4){

      category = 7;

      kickers = [grouped[0].value, grouped[1].value];

    }else if(grouped[0].count === 3 && grouped[1]?.count === 2){

      category = 6;

      kickers = [grouped[0].value, grouped[1].value];

    }else if(isFlush){

      category = 5;

      kickers = values.slice();

    }else if(straightHigh){

      category = 4;

      kickers = [straightHigh];

    }else if(grouped[0].count === 3){

      category = 3;

      const remaining = grouped.slice(1).map(item => item.value).sort((a,b) => b - a);

      kickers = [grouped[0].value, remaining[0], remaining[1]];

    }else if(grouped[0].count === 2 && grouped[1]?.count === 2){

      category = 2;

      const pairRanks = [grouped[0].value, grouped[1].value].sort((a,b) => b - a);

      const kicker = grouped.slice(2).map(item => item.value).sort((a,b) => b - a)[0];

      kickers = [pairRanks[0], pairRanks[1], kicker];

    }else if(grouped[0].count === 2){

      category = 1;

      const remaining = grouped.slice(1).map(item => item.value).sort((a,b) => b - a);

      kickers = [grouped[0].value, remaining[0], remaining[1], remaining[2]];

    }else{

      category = 0;

      kickers = values.slice();

    }

    return {

      name:handDescription(category, grouped, straightHigh),

      score:[category, ...kickers]

    };

  }



  function detectStraight(values){

    const unique = Array.from(new Set(values)).sort((a,b) => a - b);

    if(unique.includes(14)){

      unique.unshift(1);

    }

    let run = 1;

    let best = null;

    for(let i=1; i<unique.length; i++){

      if(unique[i] === unique[i-1] + 1){

        run++;

      }else if(unique[i] !== unique[i-1]){

        run = 1;

      }

      if(run >= 5){

        best = unique[i];

      }

    }

    if(best === 1){

      return 5;

    }

    return best;

  }



  function handDescription(category, grouped, straightHigh){

    switch(category){

      case 8: return straightHigh === 14 ? 'Royal Flush' : `Straight Flush (${rankWord(straightHigh)} high)`;

      case 7: return `Four of a Kind (${rankPlural(grouped[0].value)})`;

      case 6: return `Full House (${rankPlural(grouped[0].value)} over ${rankPlural(grouped[1].value)})`;

      case 5: return 'Flush';

      case 4: return `Straight (${rankWord(straightHigh)} high)`;

      case 3: return `Three of a Kind (${rankPlural(grouped[0].value)})`;

      case 2: return `Two Pair (${rankPlural(grouped[0].value)} and ${rankPlural(grouped[1].value)})`;

      case 1: return `One Pair (${rankPlural(grouped[0].value)})`;

      default: return `${rankWord(grouped[0].value)} High`;

    }

  }



  function compareScores(a, b){

    const len = Math.max(a.length, b.length);

    for(let i=0; i<len; i++){

      const av = a[i] ?? 0;

      const bv = b[i] ?? 0;

      if(av !== bv){

        return av - bv;

      }

    }

    return 0;

  }



  function formatChips(amount){

    return `${amount.toLocaleString()}`;

  }



  function formatCard(card){

    if(!card) return '';

    const rankLabel = card.rank === 'T' ? '10' : card.rank;

    return `${rankLabel}${SUIT_SYMBOLS[card.suit]}`;

  }


  function formatCardList(cards){

    return cards.map(formatCard).join(' ');

  }



  function rankWord(value){

    const mapping = { 14:'Ace', 13:'King', 12:'Queen', 11:'Jack', 10:'Ten', 9:'Nine', 8:'Eight',7:'Seven',6:'Six',5:'Five',4:'Four',3:'Three',2:'Two',1:'Ace' };

    return mapping[value] || value;

  }



  function rankPlural(value){

    const mapping = { 14:'Aces', 13:'Kings', 12:'Queens', 11:'Jacks', 10:'Tens', 9:'Nines', 8:'Eights',7:'Sevens',6:'Sixes',5:'Fives',4:'Fours',3:'Threes',2:'Twos',1:'Aces' };

    return mapping[value] || `${value}s`;

  }



  function ordinal(n){

    const suffix = n % 10 === 1 && n % 100 !== 11 ? 'st' :

      n % 10 === 2 && n % 100 !== 12 ? 'nd' :

      n % 10 === 3 && n % 100 !== 13 ? 'rd' : 'th';

    return `${n}${suffix}`;

  }



  function containsCard(collection, target){

    return collection.some(card => card.code === target.code);

  }



  function clamp(value, min, max){

    return Math.max(min, Math.min(max, value));

  }



  function clearPendingTimeout(){

    if(state.pendingTimeout){

      clearTimeout(state.pendingTimeout);

      state.pendingTimeout = null;

    }

  }

  // Chip visualization overrides

  chipDisplay.bets = chipDisplay.bets || Array.from({ length:8 }, () => ({ amount:0, chips:[] }));



  const STACK_LAYOUTS = [

    { spread:11, verticalStep:5, perRow:3, stackSize:18, stackOffset:26, baseLift:8, stackDirection:'symmetric', orientation:'up' },

    { spread:9, verticalStep:5, perRow:3, stackSize:18, stackOffset:24, baseLift:6, stackDirection:-1, orientation:'up' },

    { spread:9, verticalStep:5, perRow:3, stackSize:18, stackOffset:22, baseLift:5, stackDirection:-1, orientation:'up' },

    { spread:9, verticalStep:5, perRow:3, stackSize:18, stackOffset:22, baseLift:4, stackDirection:-1, orientation:'up' },

    { spread:11, verticalStep:5, perRow:3, stackSize:18, stackOffset:26, baseLift:8, stackDirection:'symmetric', orientation:'up' },

    { spread:9, verticalStep:5, perRow:3, stackSize:18, stackOffset:22, baseLift:4, stackDirection:1, orientation:'up' },

    { spread:9, verticalStep:5, perRow:3, stackSize:18, stackOffset:22, baseLift:5, stackDirection:1, orientation:'up' },

    { spread:9, verticalStep:5, perRow:3, stackSize:18, stackOffset:24, baseLift:6, stackDirection:1, orientation:'up' }

  ];



  function stackLayoutForSeat(seat){

    const layout = STACK_LAYOUTS[seat];

    return layout ? { ...layout } : { ...STACK_LAYOUTS[0] };

  }



  function betLayoutForSeat(seat){

    const base = stackLayoutForSeat(seat);

    const spread = base.spread ?? 8;

    const offset = base.stackOffset ?? spread * 3;

    const lift = base.baseLift ?? 0;

    return {

      ...base,

      spread: Math.max(6, Math.round(spread * 0.85)),

      stackOffset: Math.max(16, Math.round(offset * 0.7)),

      baseLift: Math.max(1, Math.round(lift * 0.5)),

      stackDirection: base.stackDirection === 'symmetric' ? 'symmetric' : base.stackDirection,

      orientation:'radial'

    };

  }



  function potLayoutOptions(){

    return { spread:12, verticalStep:5, perRow:4, stackSize:24, stackOffset:24, baseLift:2, stackDirection:'symmetric', orientation:'radial' };

  }



  function setChipPosition(chip, anchor, index, spread = 8, verticalStep = 4, options = {}){

    if(!anchor || !chip || !elements.chipLayer){

      return;

    }



    const layerRect = elements.chipLayer.getBoundingClientRect();

    const anchorRect = anchor.getBoundingClientRect();

    const centerX = anchorRect.left - layerRect.left + anchorRect.width / 2;

    const centerY = anchorRect.top - layerRect.top + anchorRect.height / 2;

    const baseSpread = options.spread ?? spread;

    const baseVertical = options.verticalStep ?? verticalStep;

    const perRow = Math.max(1, Math.floor(options.perRow ?? 3));

    const stackSize = Math.max(perRow, Math.floor(options.stackSize ?? perRow * 4));

    const baseStackOffset = options.stackOffset ?? baseSpread * perRow;

    const baseLift = options.baseLift ?? 0;

    const baseJitter = options.jitter ?? 0;

    const chipSize = chip.offsetWidth || 38;

    const chipRadius = chipSize / 2;

    const sizeRatio = chipSize / 38;

    const effectiveSpread = baseSpread * sizeRatio;

    const effectiveVertical = baseVertical * sizeRatio;

    const stackOffset = baseStackOffset * sizeRatio;

    const lift = baseLift * sizeRatio;

    const jitter = baseJitter * sizeRatio;

    const orientation = (options.orientation || '').toLowerCase();

    const layerCenterX = layerRect.width / 2;

    const layerCenterY = layerRect.height / 2;

    let dirX = centerX - layerCenterX;

    let dirY = centerY - layerCenterY;

    const magnitude = Math.hypot(dirX, dirY) || 1;

    dirX /= magnitude;

    dirY /= magnitude;

    const tangentX = -dirY;

    const tangentY = dirX;

    const stackIndex = Math.floor(index / stackSize);

    const indexWithinStack = index % stackSize;

    const column = indexWithinStack % perRow;

    const row = Math.floor(indexWithinStack / perRow);

    let lateralBase = 0;

    const stackDirection = options.stackDirection;

    if(stackIndex > 0){

      if(stackDirection === 'symmetric'){

        const step = Math.ceil(stackIndex / 2);

        const side = stackIndex % 2 === 1 ? -1 : 1;

        lateralBase = step * stackOffset * side;

      }else{

        let dir = stackDirection;

        if(typeof dir !== 'number' || !Number.isFinite(dir)){

          dir = centerX >= layerCenterX ? 1 : -1;

        }else{

          dir = dir >= 0 ? 1 : -1;

        }

        lateralBase = stackIndex * stackOffset * dir;

      }

    }

    const columnOffset = (column - (perRow - 1) / 2) * effectiveSpread;

    const lateral = columnOffset + lateralBase;

    const vertical = lift + row * effectiveVertical;

    let offsetX;

    let offsetY;

    if(orientation === 'up' || orientation === 'vertical'){

      offsetX = lateral;

      offsetY = -(vertical);

    }else{

      const radial = vertical;

      offsetX = tangentX * lateral + dirX * radial;

      offsetY = tangentY * lateral + dirY * radial;

    }

    if(jitter){

      offsetX += (Math.random() - 0.5) * jitter;

      offsetY += (Math.random() - 0.5) * jitter;

    }

    chip.style.left = `${centerX - chipRadius + offsetX}px`;

    chip.style.top = `${centerY - chipRadius + offsetY}px`;

    const angle = chip.dataset.angle || (Math.random() * 26 - 13).toFixed(1);

    chip.dataset.angle = angle;

    chip.style.transform = `rotate(${angle}deg)`;

  }



  function layoutChipGroup(anchor, chips, options = {}){

    if(!anchor || !chips || !chips.length || !elements.chipLayer){

      return;

    }

    const config = { ...options };

    const spread = config.spread ?? 8;

    const verticalStep = config.verticalStep ?? 4;

    config.spread = spread;

    config.verticalStep = verticalStep;

    chips.forEach(chip => { chip.style.transitionDuration = '0ms'; });

    chips.forEach((chip, idx) => setChipPosition(chip, anchor, idx, spread, verticalStep, config));

    requestAnimationFrame(() => {

      chips.forEach(chip => { chip.style.transitionDuration = ''; });

    });

  }



  function clearChipDisplays(){

    chipDisplay.stacks.forEach(store => {

      if(store && store.chips){

        store.chips.forEach(chip => chip.remove());

      }

    });

    chipDisplay.stacks = Array.from({ length:8 }, () => ({ amount:0, chips:[] }));

    chipDisplay.bets.forEach(store => {

      if(store && store.chips){

        store.chips.forEach(chip => chip.remove());

      }

    });

    chipDisplay.bets = Array.from({ length:8 }, () => ({ amount:0, chips:[] }));

    if(chipDisplay.pot && chipDisplay.pot.chips){

      chipDisplay.pot.chips.forEach(chip => chip.remove());

    }

    chipDisplay.pot = { amount:0, chips:[] };

  }



  function relayoutStaticChips(){

    if(!elements.chipLayer){

      return;

    }

    chipDisplay.stacks.forEach((store, seat) => {

      if(store && store.chips && store.chips.length && chipDisplay.anchors.stack[seat]){

        layoutChipGroup(chipDisplay.anchors.stack[seat], store.chips, stackLayoutForSeat(seat));

      }

    });

    chipDisplay.bets.forEach((store, seat) => {

      if(store && store.chips && store.chips.length && chipDisplay.anchors.bet[seat]){

        layoutChipGroup(chipDisplay.anchors.bet[seat], store.chips, betLayoutForSeat(seat));

      }

    });

    if(chipDisplay.pot && chipDisplay.pot.chips && chipDisplay.pot.chips.length && chipDisplay.anchors.pot){

      layoutChipGroup(chipDisplay.anchors.pot, chipDisplay.pot.chips, potLayoutOptions());

    }

  }



  function resetChipDisplays(){

    if(!elements.chipLayer){

      return;

    }

    if(!chipDisplay.anchors.pot){

      setupChipLayer();

    }

    clearChipDisplays();

    state.players.forEach(player => {

      updateStackDisplay(player);

      updateBetDisplay(player);

    });

    const collectedPot = chipDisplay.pot && typeof chipDisplay.pot.amount === 'number'
      ? chipDisplay.pot.amount
      : 0;

    updatePotChips(collectedPot);

    renderPot();

    scheduleChipRelayout();

  }



  function updateStackDisplay(player, delay = 0){

    if(!player || typeof player.seat !== 'number'){

      return;

    }

    const seat = player.seat;

    const anchor = chipDisplay.anchors.stack[seat];

    if(!anchor){

      return;

    }

    const layout = stackLayoutForSeat(seat);

    const current = chipDisplay.stacks[seat];

    const targetNow = Math.max(0, Math.round(player.chips || 0));

    if(!delay && current && current.amount === targetNow){

      return;

    }

    const apply = () => {

      const targetAmount = Math.max(0, Math.round(player.chips || 0));

      const store = chipDisplay.stacks[seat];

      if(store && store.chips){

        store.chips.forEach(chip => chip.remove());

      }

      const chips = buildChipElements(targetAmount);

      chips.forEach(chip => elements.chipLayer.appendChild(chip));

      layoutChipGroup(anchor, chips, layout);

      chipDisplay.stacks[seat] = { amount:targetAmount, chips };

    };

    if(delay){

      setTimeout(apply, delay);

    }else{

      apply();

    }

  }



  function updateBetDisplay(player, delay = 0){

    if(!player || typeof player.seat !== 'number'){

      return;

    }

    const seat = player.seat;

    const anchor = chipDisplay.anchors.bet[seat] || chipDisplay.anchors.stack[seat];

    if(!anchor){

      return;

    }

    const layout = betLayoutForSeat(seat);

    const current = chipDisplay.bets[seat];

    const targetNow = Math.max(0, Math.round(player.bet || 0));

    if(!delay && current && current.amount === targetNow){

      return;

    }

    const apply = () => {

      const targetAmount = Math.max(0, Math.round(player.bet || 0));

      const store = chipDisplay.bets[seat];

      if(store && store.chips){

        store.chips.forEach(chip => chip.remove());

      }

      if(targetAmount <= 0){

        chipDisplay.bets[seat] = { amount:0, chips:[] };

        return;

      }

      const chips = buildChipElements(targetAmount);

      chips.forEach(chip => elements.chipLayer.appendChild(chip));

      layoutChipGroup(anchor, chips, layout);

      chipDisplay.bets[seat] = { amount:targetAmount, chips };

    };

    if(delay){

      setTimeout(apply, delay);

    }else{

      apply();

    }

  }



  function updatePotChips(amount, delay = 0){

    const anchor = chipDisplay.anchors.pot;

    if(!anchor){

      return;

    }

    const layout = potLayoutOptions();

    const targetAmount = Math.max(0, Math.round(amount || 0));

    if(!delay && chipDisplay.pot && chipDisplay.pot.amount === targetAmount){

      return;

    }

    const apply = () => {

      if(chipDisplay.pot.chips){

        chipDisplay.pot.chips.forEach(chip => chip.remove());

      }

      const chips = buildChipElements(targetAmount);

      chips.forEach(chip => elements.chipLayer.appendChild(chip));

      layoutChipGroup(anchor, chips, layout);

      chipDisplay.pot = { amount:targetAmount, chips };

    };

    if(delay){

      setTimeout(apply, delay);

    }else{

      apply();

    }

  }



  function animateChipsBetween(fromAnchor, toAnchor, amount, options = {}){

    if(!elements.chipLayer || !fromAnchor || !toAnchor || !amount){

      if(typeof options.onComplete === 'function'){

        options.onComplete();

      }

      return;

    }

    const chips = buildChipElements(amount);

    if(!chips.length){

      if(typeof options.onComplete === 'function'){

        options.onComplete();

      }

      return;

    }

    const layer = elements.chipLayer;

    const baseSpread = options.spread ?? options.layout?.spread ?? 8;

    const baseVertical = options.verticalStep ?? options.layout?.verticalStep ?? 4;

    const fromLayout = { ...(options.layout || {}), ...(options.fromLayout || {}) };

    const toLayout = { ...(options.layout || {}), ...(options.toLayout || {}) };

    const fromSpread = fromLayout.spread ?? baseSpread;

    const fromVertical = fromLayout.verticalStep ?? baseVertical;

    const toSpread = toLayout.spread ?? baseSpread;

    const toVertical = toLayout.verticalStep ?? baseVertical;

    fromLayout.spread = fromSpread;

    fromLayout.verticalStep = fromVertical;

    toLayout.spread = toSpread;

    toLayout.verticalStep = toVertical;

    const duration = options.duration ?? CHIP_ANIMATION_DURATION;

    chips.forEach((chip, idx) => {

      chip.classList.add('chip-floating');

      chip.style.transitionDuration = '0ms';

      layer.appendChild(chip);

      setChipPosition(chip, fromAnchor, idx, fromSpread, fromVertical, fromLayout);

    });

    requestAnimationFrame(() => {

      chips.forEach(chip => { chip.style.transitionDuration = `${duration}ms`; });

      requestAnimationFrame(() => {

        chips.forEach((chip, idx) => setChipPosition(chip, toAnchor, idx, toSpread, toVertical, toLayout));

      });

    });

    setTimeout(() => {

      chips.forEach(chip => chip.remove());

      if(typeof options.onComplete === 'function'){

        options.onComplete();

      }

    }, duration + 60);

  }



  function animateCommitChips(player, amount, animationOptions){

    if(!player || amount <= 0){

      updateBetDisplay(player);

      return;

    }

    const seatAnchor = chipDisplay.anchors.stack[player.seat];

    const betAnchor = chipDisplay.anchors.bet[player.seat] || seatAnchor;

    if(!seatAnchor || !betAnchor){

      updateBetDisplay(player);

      updateStackDisplay(player);

      return;

    }

    const seatLayout = stackLayoutForSeat(player.seat);

    const betLayout = betLayoutForSeat(player.seat);

    const chips = buildChipElements(amount);

    if(!chips.length){

      updateBetDisplay(player);

      return;

    }

    const duration = animationOptions && animationOptions.kind === 'blind' ? Math.max(280, Math.round(CHIP_ANIMATION_DURATION * 0.6)) : CHIP_ANIMATION_DURATION;

    const layer = elements.chipLayer;

    chips.forEach((chip, idx) => {

      chip.classList.add('chip-floating');

      chip.style.transitionDuration = '0ms';

      layer.appendChild(chip);

      setChipPosition(chip, seatAnchor, idx, seatLayout.spread, seatLayout.verticalStep, seatLayout);

    });

    requestAnimationFrame(() => {

      chips.forEach(chip => { chip.style.transitionDuration = `${duration}ms`; });

      requestAnimationFrame(() => {

        chips.forEach((chip, idx) => setChipPosition(chip, betAnchor, idx, betLayout.spread, betLayout.verticalStep, betLayout));

      });

    });

    setTimeout(() => {

      chips.forEach(chip => chip.remove());

      updateBetDisplay(player);

    }, duration + 60);

    updateStackDisplay(player, duration);

  }



  function animatePotToSeat(player, amount){

    if(!player || amount <= 0){

      updateStackDisplay(player);

      updatePotChips(state.pot);

      return;

    }

    const seatAnchor = chipDisplay.anchors.stack[player.seat];

    const potAnchor = chipDisplay.anchors.pot;

    if(!seatAnchor || !potAnchor){

      updateStackDisplay(player);

      updatePotChips(state.pot);

      return;

    }

    animateChipsBetween(potAnchor, seatAnchor, amount, {

      fromLayout: potLayoutOptions(),

      toLayout: stackLayoutForSeat(player.seat),

      onComplete: () => {

        updateStackDisplay(player);

        updatePotChips(state.pot);

      }

    });

  }



  function collectBetDisplaysIntoPot(options = {}){

    const immediate = !!options.immediate;

    const onComplete = typeof options.onComplete === 'function' ? options.onComplete : null;

    const potAnchor = chipDisplay.anchors.pot;

    if(!potAnchor){

      if(onComplete){ onComplete(); }

      return;

    }

    const potLayout = potLayoutOptions();

    let pending = 0;

    const finish = () => {

      updatePotChips(state.pot);

      if(onComplete){ onComplete(); }

    };

    state.players.forEach((player, seat) => {

      const store = chipDisplay.bets[seat];

      const amountFromStore = store ? store.amount : 0;

      const amount = Math.max(amountFromStore, Math.max(0, Math.round((player && player.bet) || 0)));

      const betAnchor = chipDisplay.anchors.bet[seat] || chipDisplay.anchors.stack[seat];

      if(!amount || !betAnchor){

        if(store && store.chips){ store.chips.forEach(chip => chip.remove()); }

        chipDisplay.bets[seat] = { amount:0, chips:[] };

        return;

      }

      if(store && store.chips){ store.chips.forEach(chip => chip.remove()); }

      chipDisplay.bets[seat] = { amount:0, chips:[] };

      if(immediate){

        return;

      }

      pending++;

      animateChipsBetween(betAnchor, potAnchor, amount, {

        fromLayout: betLayoutForSeat(seat),

        toLayout: potLayout,

        onComplete: () => {

          pending--;

          if(pending === 0){

            finish();

          }

        }

      });

    });

    if(immediate || pending === 0){

      finish();

    }

  }



  const originalResetRoundBets = resetRoundBets;

  resetRoundBets = function(){

    collectBetDisplaysIntoPot();

    originalResetRoundBets();

    state.players.forEach(player => updateBetDisplay(player));

  };



  const originalHandleSingleRemaining = handleSingleRemaining;

  handleSingleRemaining = function(forcedWinner){

    collectBetDisplaysIntoPot({ immediate:true });

    return originalHandleSingleRemaining(forcedWinner);

  };



  const originalResolveShowdown = resolveShowdown;

  resolveShowdown = function(){

    collectBetDisplaysIntoPot({ immediate:true });

    originalResolveShowdown();

  };



  const originalResetState = resetState;

  resetState = function(){

    collectBetDisplaysIntoPot({ immediate:true });

    originalResetState();

  };



  const originalResetBoard = resetBoard;

  resetBoard = function(){

    collectBetDisplaysIntoPot({ immediate:true });

    originalResetBoard();

  };



})();

</script>

</body>

</html>
